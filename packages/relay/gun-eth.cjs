'use strict';

var ethers = require('ethers');
var Gun = require('gun');
var SEA$1 = require('gun/sea.js');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
var _format$2 = "hh-sol-artifact-1";
var contractName$2 = "StealthAnnouncer";
var sourceName$2 = "contracts/StealthAnnouncer.sol";
var abi$2 = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_devAddress",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "newAddress",
				type: "address"
			}
		],
		name: "DevAddressUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "uint256",
				name: "newFee",
				type: "uint256"
			}
		],
		name: "DevFeeUpdated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "string",
				name: "senderPublicKey",
				type: "string"
			},
			{
				indexed: false,
				internalType: "string",
				name: "spendingPublicKey",
				type: "string"
			},
			{
				indexed: false,
				internalType: "address",
				name: "stealthAddress",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "timestamp",
				type: "uint256"
			}
		],
		name: "StealthPaymentAnnounced",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "string",
				name: "senderPublicKey",
				type: "string"
			},
			{
				internalType: "string",
				name: "spendingPublicKey",
				type: "string"
			},
			{
				internalType: "address",
				name: "stealthAddress",
				type: "address"
			}
		],
		name: "announcePayment",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		name: "announcements",
		outputs: [
			{
				internalType: "string",
				name: "senderPublicKey",
				type: "string"
			},
			{
				internalType: "string",
				name: "spendingPublicKey",
				type: "string"
			},
			{
				internalType: "address",
				name: "stealthAddress",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "timestamp",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "devAddress",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "devFee",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "getAnnouncementsCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "fromIndex",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "toIndex",
				type: "uint256"
			}
		],
		name: "getAnnouncementsInRange",
		outputs: [
			{
				components: [
					{
						internalType: "string",
						name: "senderPublicKey",
						type: "string"
					},
					{
						internalType: "string",
						name: "spendingPublicKey",
						type: "string"
					},
					{
						internalType: "address",
						name: "stealthAddress",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "timestamp",
						type: "uint256"
					}
				],
				internalType: "struct StealthAnnouncer.StealthAnnouncement[]",
				name: "",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "_newAddress",
				type: "address"
			}
		],
		name: "updateDevAddress",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "_newFee",
				type: "uint256"
			}
		],
		name: "updateDevFee",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "withdrawStuckETH",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var bytecode$2 = "0x6080604052655af3107a400060015534801561001a57600080fd5b50604051610e6b380380610e6b8339810160408190526100399161005e565b600080546001600160a01b0319166001600160a01b039290921691909117905561008e565b60006020828403121561007057600080fd5b81516001600160a01b038116811461008757600080fd5b9392505050565b610dce8061009d6000396000f3fe6080604052600436106100865760003560e01c80638503376211610059578063850337621461013057806399729ec114610152578063ca93e31e14610172578063eb7be2ac1461019f578063f5648a4f146101b257600080fd5b80631bcfbe311461008b5780633ad10ef6146100c45780635fabd0cd146100fc5780636827e7641461011b575b600080fd5b34801561009757600080fd5b506100ab6100a63660046108f1565b6101c7565b6040516100bb9493929190610950565b60405180910390f35b3480156100d057600080fd5b506000546100e4906001600160a01b031681565b6040516001600160a01b0390911681526020016100bb565b34801561010857600080fd5b506002545b6040519081526020016100bb565b34801561012757600080fd5b5060015461010d565b34801561013c57600080fd5b5061015061014b3660046109ae565b610321565b005b34801561015e57600080fd5b5061015061016d3660046108f1565b6103a9565b34801561017e57600080fd5b5061019261018d3660046109d0565b610408565b6040516100bb91906109f2565b6101506101ad366004610b39565b6106ec565b3480156101be57600080fd5b5061015061082c565b600281815481106101d757600080fd5b90600052602060002090600402016000915090508060000180546101fa90610bad565b80601f016020809104026020016040519081016040528092919081815260200182805461022690610bad565b80156102735780601f1061024857610100808354040283529160200191610273565b820191906000526020600020905b81548152906001019060200180831161025657829003601f168201915b50505050509080600101805461028890610bad565b80601f01602080910402602001604051908101604052809291908181526020018280546102b490610bad565b80156103015780601f106102d657610100808354040283529160200191610301565b820191906000526020600020905b8154815290600101906020018083116102e457829003601f168201915b50505050600283015460039093015491926001600160a01b031691905084565b6000546001600160a01b031633146103545760405162461bcd60e51b815260040161034b90610be7565b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081179091556040519081527f34830ecd12aee38e030de8db2aab7662959ba614a8af53e095041d13deced11d906020015b60405180910390a150565b6000546001600160a01b031633146103d35760405162461bcd60e51b815260040161034b90610be7565b60018190556040518181527fd2fcc8c801d1c6ec6267fa3420cc8428c11a8c06f0d110a700fe9ff1e73173609060200161039e565b60608282101561044a5760405162461bcd60e51b815260206004820152600d60248201526c496e76616c69642072616e676560981b604482015260640161034b565b60025482106104915760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b604482015260640161034b565b600061049d8484610c34565b6104a8906001610c47565b905060008167ffffffffffffffff8111156104c5576104c5610a96565b60405190808252806020026020018201604052801561052a57816020015b6105176040518060800160405280606081526020016060815260200160006001600160a01b03168152602001600081525090565b8152602001906001900390816104e35790505b50905060005b828110156106e15760026105448288610c47565b8154811061055457610554610c5a565b906000526020600020906004020160405180608001604052908160008201805461057d90610bad565b80601f01602080910402602001604051908101604052809291908181526020018280546105a990610bad565b80156105f65780601f106105cb576101008083540402835291602001916105f6565b820191906000526020600020905b8154815290600101906020018083116105d957829003601f168201915b5050505050815260200160018201805461060f90610bad565b80601f016020809104026020016040519081016040528092919081815260200182805461063b90610bad565b80156106885780601f1061065d57610100808354040283529160200191610688565b820191906000526020600020905b81548152906001019060200180831161066b57829003601f168201915b505050918352505060028201546001600160a01b0316602082015260039091015460409091015282518390839081106106c3576106c3610c5a565b602002602001018190525080806106d990610c70565b915050610530565b509150505b92915050565b6001543410156107315760405162461bcd60e51b815260206004820152601060248201526f496e73756666696369656e742066656560801b604482015260640161034b565b60408051608081018252848152602081018490526001600160a01b0383169181019190915242606082015260028054600181018255600091909152815160049091027f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace019081906107a29082610cd8565b50602082015160018201906107b79082610cd8565b506040828101516002830180546001600160a01b0319166001600160a01b03909216919091179055606090920151600390910155517fd473583944dff235264dba87ace9054a2b6804a696bdda5b9152f309439469119061081f908590859085904290610950565b60405180910390a1505050565b6000546001600160a01b031633146108565760405162461bcd60e51b815260040161034b90610be7565b600080546040516001600160a01b039091169047908381818185875af1925050503d80600081146108a3576040519150601f19603f3d011682016040523d82523d6000602084013e6108a8565b606091505b50509050806108ee5760405162461bcd60e51b81526020600482015260126024820152714661696c656420746f20776974686472617760701b604482015260640161034b565b50565b60006020828403121561090357600080fd5b5035919050565b6000815180845260005b8181101561093057602081850181015186830182015201610914565b506000602082860101526020601f19601f83011685010191505092915050565b608081526000610963608083018761090a565b8281036020840152610975818761090a565b6001600160a01b0395909516604084015250506060015292915050565b80356001600160a01b03811681146109a957600080fd5b919050565b6000602082840312156109c057600080fd5b6109c982610992565b9392505050565b600080604083850312156109e357600080fd5b50508035926020909101359150565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015610a8857603f19898403018552815160808151818652610a3f8287018261090a565b915050888201518582038a870152610a57828261090a565b838a01516001600160a01b0316878b0152606093840151939096019290925250509386019390860190600101610a19565b509098975050505050505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610abd57600080fd5b813567ffffffffffffffff80821115610ad857610ad8610a96565b604051601f8301601f19908116603f01168101908282118183101715610b0057610b00610a96565b81604052838152866020858801011115610b1957600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610b4e57600080fd5b833567ffffffffffffffff80821115610b6657600080fd5b610b7287838801610aac565b94506020860135915080821115610b8857600080fd5b50610b9586828701610aac565b925050610ba460408501610992565b90509250925092565b600181811c90821680610bc157607f821691505b602082108103610be157634e487b7160e01b600052602260045260246000fd5b50919050565b6020808252601f908201527f4f6e6c79206465762063616e2063616c6c20746869732066756e6374696f6e00604082015260600190565b634e487b7160e01b600052601160045260246000fd5b818103818111156106e6576106e6610c1e565b808201808211156106e6576106e6610c1e565b634e487b7160e01b600052603260045260246000fd5b600060018201610c8257610c82610c1e565b5060010190565b601f821115610cd357600081815260208120601f850160051c81016020861015610cb05750805b601f850160051c820191505b81811015610ccf57828155600101610cbc565b5050505b505050565b815167ffffffffffffffff811115610cf257610cf2610a96565b610d0681610d008454610bad565b84610c89565b602080601f831160018114610d3b5760008415610d235750858301515b600019600386901b1c1916600185901b178555610ccf565b600085815260208120601f198616915b82811015610d6a57888601518255948401946001909101908401610d4b565b5085821015610d885787850151600019600388901b60f8161c191681555b5050505050600190811b0190555056fea2646970667358221220f58212a5efb6816f361714de2406463c3216a0f527c6d00ea6b8bdf59a2261fb64736f6c63430008130033";
var deployedBytecode$2 = "0x6080604052600436106100865760003560e01c80638503376211610059578063850337621461013057806399729ec114610152578063ca93e31e14610172578063eb7be2ac1461019f578063f5648a4f146101b257600080fd5b80631bcfbe311461008b5780633ad10ef6146100c45780635fabd0cd146100fc5780636827e7641461011b575b600080fd5b34801561009757600080fd5b506100ab6100a63660046108f1565b6101c7565b6040516100bb9493929190610950565b60405180910390f35b3480156100d057600080fd5b506000546100e4906001600160a01b031681565b6040516001600160a01b0390911681526020016100bb565b34801561010857600080fd5b506002545b6040519081526020016100bb565b34801561012757600080fd5b5060015461010d565b34801561013c57600080fd5b5061015061014b3660046109ae565b610321565b005b34801561015e57600080fd5b5061015061016d3660046108f1565b6103a9565b34801561017e57600080fd5b5061019261018d3660046109d0565b610408565b6040516100bb91906109f2565b6101506101ad366004610b39565b6106ec565b3480156101be57600080fd5b5061015061082c565b600281815481106101d757600080fd5b90600052602060002090600402016000915090508060000180546101fa90610bad565b80601f016020809104026020016040519081016040528092919081815260200182805461022690610bad565b80156102735780601f1061024857610100808354040283529160200191610273565b820191906000526020600020905b81548152906001019060200180831161025657829003601f168201915b50505050509080600101805461028890610bad565b80601f01602080910402602001604051908101604052809291908181526020018280546102b490610bad565b80156103015780601f106102d657610100808354040283529160200191610301565b820191906000526020600020905b8154815290600101906020018083116102e457829003601f168201915b50505050600283015460039093015491926001600160a01b031691905084565b6000546001600160a01b031633146103545760405162461bcd60e51b815260040161034b90610be7565b60405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081179091556040519081527f34830ecd12aee38e030de8db2aab7662959ba614a8af53e095041d13deced11d906020015b60405180910390a150565b6000546001600160a01b031633146103d35760405162461bcd60e51b815260040161034b90610be7565b60018190556040518181527fd2fcc8c801d1c6ec6267fa3420cc8428c11a8c06f0d110a700fe9ff1e73173609060200161039e565b60608282101561044a5760405162461bcd60e51b815260206004820152600d60248201526c496e76616c69642072616e676560981b604482015260640161034b565b60025482106104915760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b604482015260640161034b565b600061049d8484610c34565b6104a8906001610c47565b905060008167ffffffffffffffff8111156104c5576104c5610a96565b60405190808252806020026020018201604052801561052a57816020015b6105176040518060800160405280606081526020016060815260200160006001600160a01b03168152602001600081525090565b8152602001906001900390816104e35790505b50905060005b828110156106e15760026105448288610c47565b8154811061055457610554610c5a565b906000526020600020906004020160405180608001604052908160008201805461057d90610bad565b80601f01602080910402602001604051908101604052809291908181526020018280546105a990610bad565b80156105f65780601f106105cb576101008083540402835291602001916105f6565b820191906000526020600020905b8154815290600101906020018083116105d957829003601f168201915b5050505050815260200160018201805461060f90610bad565b80601f016020809104026020016040519081016040528092919081815260200182805461063b90610bad565b80156106885780601f1061065d57610100808354040283529160200191610688565b820191906000526020600020905b81548152906001019060200180831161066b57829003601f168201915b505050918352505060028201546001600160a01b0316602082015260039091015460409091015282518390839081106106c3576106c3610c5a565b602002602001018190525080806106d990610c70565b915050610530565b509150505b92915050565b6001543410156107315760405162461bcd60e51b815260206004820152601060248201526f496e73756666696369656e742066656560801b604482015260640161034b565b60408051608081018252848152602081018490526001600160a01b0383169181019190915242606082015260028054600181018255600091909152815160049091027f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace019081906107a29082610cd8565b50602082015160018201906107b79082610cd8565b506040828101516002830180546001600160a01b0319166001600160a01b03909216919091179055606090920151600390910155517fd473583944dff235264dba87ace9054a2b6804a696bdda5b9152f309439469119061081f908590859085904290610950565b60405180910390a1505050565b6000546001600160a01b031633146108565760405162461bcd60e51b815260040161034b90610be7565b600080546040516001600160a01b039091169047908381818185875af1925050503d80600081146108a3576040519150601f19603f3d011682016040523d82523d6000602084013e6108a8565b606091505b50509050806108ee5760405162461bcd60e51b81526020600482015260126024820152714661696c656420746f20776974686472617760701b604482015260640161034b565b50565b60006020828403121561090357600080fd5b5035919050565b6000815180845260005b8181101561093057602081850181015186830182015201610914565b506000602082860101526020601f19601f83011685010191505092915050565b608081526000610963608083018761090a565b8281036020840152610975818761090a565b6001600160a01b0395909516604084015250506060015292915050565b80356001600160a01b03811681146109a957600080fd5b919050565b6000602082840312156109c057600080fd5b6109c982610992565b9392505050565b600080604083850312156109e357600080fd5b50508035926020909101359150565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015610a8857603f19898403018552815160808151818652610a3f8287018261090a565b915050888201518582038a870152610a57828261090a565b838a01516001600160a01b0316878b0152606093840151939096019290925250509386019390860190600101610a19565b509098975050505050505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610abd57600080fd5b813567ffffffffffffffff80821115610ad857610ad8610a96565b604051601f8301601f19908116603f01168101908282118183101715610b0057610b00610a96565b81604052838152866020858801011115610b1957600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610b4e57600080fd5b833567ffffffffffffffff80821115610b6657600080fd5b610b7287838801610aac565b94506020860135915080821115610b8857600080fd5b50610b9586828701610aac565b925050610ba460408501610992565b90509250925092565b600181811c90821680610bc157607f821691505b602082108103610be157634e487b7160e01b600052602260045260246000fd5b50919050565b6020808252601f908201527f4f6e6c79206465762063616e2063616c6c20746869732066756e6374696f6e00604082015260600190565b634e487b7160e01b600052601160045260246000fd5b818103818111156106e6576106e6610c1e565b808201808211156106e6576106e6610c1e565b634e487b7160e01b600052603260045260246000fd5b600060018201610c8257610c82610c1e565b5060010190565b601f821115610cd357600081815260208120601f850160051c81016020861015610cb05750805b601f850160051c820191505b81811015610ccf57828155600101610cbc565b5050505b505050565b815167ffffffffffffffff811115610cf257610cf2610a96565b610d0681610d008454610bad565b84610c89565b602080601f831160018114610d3b5760008415610d235750858301515b600019600386901b1c1916600185901b178555610ccf565b600085815260208120601f198616915b82811015610d6a57888601518255948401946001909101908401610d4b565b5085821015610d885787850151600019600388901b60f8161c191681555b5050505050600190811b0190555056fea2646970667358221220f58212a5efb6816f361714de2406463c3216a0f527c6d00ea6b8bdf59a2261fb64736f6c63430008130033";
var linkReferences$2 = {
};
var deployedLinkReferences$2 = {
};
var StealthAnnouncerArtifact = {
	_format: _format$2,
	contractName: contractName$2,
	sourceName: sourceName$2,
	abi: abi$2,
	bytecode: bytecode$2,
	deployedBytecode: deployedBytecode$2,
	linkReferences: linkReferences$2,
	deployedLinkReferences: deployedLinkReferences$2
};

var _format$1 = "hh-sol-artifact-1";
var contractName$1 = "BubbleRegistry";
var sourceName$1 = "contracts/BubbleRegistry.sol";
var abi$1 = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "grantor",
				type: "address"
			}
		],
		name: "AccessGranted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "user",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "revoker",
				type: "address"
			}
		],
		name: "AccessRevoked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				indexed: true,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "isPrivate",
				type: "bool"
			}
		],
		name: "BubbleCreated",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			}
		],
		name: "BubbleDeleted",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "bubbles",
		outputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "createdAt",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "isPrivate",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "bool",
				name: "isPrivate",
				type: "bool"
			}
		],
		name: "createBubble",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			}
		],
		name: "deleteBubble",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			}
		],
		name: "getBubbleDetails",
		outputs: [
			{
				internalType: "string",
				name: "name",
				type: "string"
			},
			{
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "createdAt",
				type: "uint256"
			},
			{
				internalType: "bool",
				name: "isPrivate",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "user",
				type: "address"
			}
		],
		name: "grantAccess",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "user",
				type: "address"
			}
		],
		name: "hasAccess",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "bubbleId",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "user",
				type: "address"
			}
		],
		name: "revokeAccess",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	}
];
var bytecode$1 = "0x608060405234801561001057600080fd5b50610b90806100206000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c806340554c3a1161005b57806340554c3a146100e057806374291358146100f357806383177db3146101065780638d53b2081461012957600080fd5b806302abd636146100825780631b8fbadc146100a85780631e77a815146100bd575b600080fd5b6100956100903660046107e3565b61013c565b6040519081526020015b60405180910390f35b6100bb6100b63660046108a5565b610274565b005b6100d06100cb3660046108a5565b61031a565b60405161009f949392919061090e565b6100bb6100ee366004610948565b6103d9565b6100d06101013660046108a5565b6104e5565b610119610114366004610948565b6105be565b604051901515815260200161009f565b6100bb610137366004610948565b61060d565b60008083334260405160200161015493929190610984565b60408051601f198184030181529181528151602092830120600081815292839052912060020154909150156101c85760405162461bcd60e51b8152602060048201526015602482015274427562626c6520616c72656164792065786973747360581b60448201526064015b60405180910390fd5b6000818152602081905260409020806101e18682610a4c565b50600180820180546001600160a01b0319163390811790915542600284015560038301805487151560ff199182161790915560008281526004850160205260409081902080549092169093179055905183907ff044551e1b1324af60e5b3736ce9012589d4e1e3061d0f620d20543ce0b06d00906102629089908990610b0c565b60405180910390a35090505b92915050565b6000818152602081905260409020600101546001600160a01b031633146102ad5760405162461bcd60e51b81526004016101bf90610b30565b6000818152602081905260408120906102c68282610762565b506001810180546001600160a01b03191690556000600282018190556003909101805460ff1916905560405182917fa83cbc31505645fe7917ca8af3507febeaac4e845b274dcc9d4b85d0a0cd45fa91a250565b600060208190529081526040902080548190610335906109c3565b80601f0160208091040260200160405190810160405280929190818152602001828054610361906109c3565b80156103ae5780601f10610383576101008083540402835291602001916103ae565b820191906000526020600020905b81548152906001019060200180831161039157829003601f168201915b505050506001830154600284015460039094015492936001600160a01b039091169290915060ff1684565b6000828152602081905260409020600101546001600160a01b031633146104125760405162461bcd60e51b81526004016101bf90610b30565b6000828152602081815260408083206001600160a01b038516845260040190915290205460ff16156104865760405162461bcd60e51b815260206004820152601760248201527f5573657220616c7265616479206861732061636365737300000000000000000060448201526064016101bf565b6000828152602081815260408083206001600160a01b0385168085526004909101909252808320805460ff1916600117905551339285917f7aeffe35f64b55a7c424c5fccc3fba0f3ac4ebd764cc737855b8734834458f2b9190a45050565b600081815260208190526040812060018101546002820154600383015483546060959485948594919384936001600160a01b03909216929160ff90911690849061052e906109c3565b80601f016020809104026020016040519081016040528092919081815260200182805461055a906109c3565b80156105a75780601f1061057c576101008083540402835291602001916105a7565b820191906000526020600020905b81548152906001019060200180831161058a57829003601f168201915b505050505093509450945094509450509193509193565b60008281526020819052604081206003015460ff166105df5750600161026e565b506000828152602081815260408083206001600160a01b038516845260040190915290205460ff1692915050565b6000828152602081905260409020600101546001600160a01b031633146106465760405162461bcd60e51b81526004016101bf90610b30565b336001600160a01b0382160361069e5760405162461bcd60e51b815260206004820152601a60248201527f43616e6e6f74207265766f6b65206f776e65722061636365737300000000000060448201526064016101bf565b6000828152602081815260408083206001600160a01b038516845260040190915290205460ff166107065760405162461bcd60e51b81526020600482015260126024820152715573657220686173206e6f2061636365737360701b60448201526064016101bf565b6000828152602081815260408083206001600160a01b0385168085526004909101909252808320805460ff1916905551339285917ffab19bdeacf1ea13315b1da3f79a3403fe4f16793b6a03eeff9e0bbbea24fe5f9190a45050565b50805461076e906109c3565b6000825580601f1061077e575050565b601f01602090049060005260206000209081019061079c919061079f565b50565b5b808211156107b457600081556001016107a0565b5090565b634e487b7160e01b600052604160045260246000fd5b803580151581146107de57600080fd5b919050565b600080604083850312156107f657600080fd5b823567ffffffffffffffff8082111561080e57600080fd5b818501915085601f83011261082257600080fd5b813581811115610834576108346107b8565b604051601f8201601f19908116603f0116810190838211818310171561085c5761085c6107b8565b8160405282815288602084870101111561087557600080fd5b82602086016020830137600060208483010152809650505050505061089c602084016107ce565b90509250929050565b6000602082840312156108b757600080fd5b5035919050565b60005b838110156108d95781810151838201526020016108c1565b50506000910152565b600081518084526108fa8160208601602086016108be565b601f01601f19169290920160200192915050565b60808152600061092160808301876108e2565b6001600160a01b039590951660208301525060408101929092521515606090910152919050565b6000806040838503121561095b57600080fd5b8235915060208301356001600160a01b038116811461097957600080fd5b809150509250929050565b600084516109968184602089016108be565b60609490941b6bffffffffffffffffffffffff191691909301908152601481019190915260340192915050565b600181811c908216806109d757607f821691505b6020821081036109f757634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115610a4757600081815260208120601f850160051c81016020861015610a245750805b601f850160051c820191505b81811015610a4357828155600101610a30565b5050505b505050565b815167ffffffffffffffff811115610a6657610a666107b8565b610a7a81610a7484546109c3565b846109fd565b602080601f831160018114610aaf5760008415610a975750858301515b600019600386901b1c1916600185901b178555610a43565b600085815260208120601f198616915b82811015610ade57888601518255948401946001909101908401610abf565b5085821015610afc5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b604081526000610b1f60408301856108e2565b905082151560208301529392505050565b60208082526010908201526f2737ba10313ab13136329037bbb732b960811b60408201526060019056fea2646970667358221220f9a873287a60effd7137ca1e0056e6b461b1013534f0cd40351a0e6cb500070564736f6c63430008130033";
var deployedBytecode$1 = "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c806340554c3a1161005b57806340554c3a146100e057806374291358146100f357806383177db3146101065780638d53b2081461012957600080fd5b806302abd636146100825780631b8fbadc146100a85780631e77a815146100bd575b600080fd5b6100956100903660046107e3565b61013c565b6040519081526020015b60405180910390f35b6100bb6100b63660046108a5565b610274565b005b6100d06100cb3660046108a5565b61031a565b60405161009f949392919061090e565b6100bb6100ee366004610948565b6103d9565b6100d06101013660046108a5565b6104e5565b610119610114366004610948565b6105be565b604051901515815260200161009f565b6100bb610137366004610948565b61060d565b60008083334260405160200161015493929190610984565b60408051601f198184030181529181528151602092830120600081815292839052912060020154909150156101c85760405162461bcd60e51b8152602060048201526015602482015274427562626c6520616c72656164792065786973747360581b60448201526064015b60405180910390fd5b6000818152602081905260409020806101e18682610a4c565b50600180820180546001600160a01b0319163390811790915542600284015560038301805487151560ff199182161790915560008281526004850160205260409081902080549092169093179055905183907ff044551e1b1324af60e5b3736ce9012589d4e1e3061d0f620d20543ce0b06d00906102629089908990610b0c565b60405180910390a35090505b92915050565b6000818152602081905260409020600101546001600160a01b031633146102ad5760405162461bcd60e51b81526004016101bf90610b30565b6000818152602081905260408120906102c68282610762565b506001810180546001600160a01b03191690556000600282018190556003909101805460ff1916905560405182917fa83cbc31505645fe7917ca8af3507febeaac4e845b274dcc9d4b85d0a0cd45fa91a250565b600060208190529081526040902080548190610335906109c3565b80601f0160208091040260200160405190810160405280929190818152602001828054610361906109c3565b80156103ae5780601f10610383576101008083540402835291602001916103ae565b820191906000526020600020905b81548152906001019060200180831161039157829003601f168201915b505050506001830154600284015460039094015492936001600160a01b039091169290915060ff1684565b6000828152602081905260409020600101546001600160a01b031633146104125760405162461bcd60e51b81526004016101bf90610b30565b6000828152602081815260408083206001600160a01b038516845260040190915290205460ff16156104865760405162461bcd60e51b815260206004820152601760248201527f5573657220616c7265616479206861732061636365737300000000000000000060448201526064016101bf565b6000828152602081815260408083206001600160a01b0385168085526004909101909252808320805460ff1916600117905551339285917f7aeffe35f64b55a7c424c5fccc3fba0f3ac4ebd764cc737855b8734834458f2b9190a45050565b600081815260208190526040812060018101546002820154600383015483546060959485948594919384936001600160a01b03909216929160ff90911690849061052e906109c3565b80601f016020809104026020016040519081016040528092919081815260200182805461055a906109c3565b80156105a75780601f1061057c576101008083540402835291602001916105a7565b820191906000526020600020905b81548152906001019060200180831161058a57829003601f168201915b505050505093509450945094509450509193509193565b60008281526020819052604081206003015460ff166105df5750600161026e565b506000828152602081815260408083206001600160a01b038516845260040190915290205460ff1692915050565b6000828152602081905260409020600101546001600160a01b031633146106465760405162461bcd60e51b81526004016101bf90610b30565b336001600160a01b0382160361069e5760405162461bcd60e51b815260206004820152601a60248201527f43616e6e6f74207265766f6b65206f776e65722061636365737300000000000060448201526064016101bf565b6000828152602081815260408083206001600160a01b038516845260040190915290205460ff166107065760405162461bcd60e51b81526020600482015260126024820152715573657220686173206e6f2061636365737360701b60448201526064016101bf565b6000828152602081815260408083206001600160a01b0385168085526004909101909252808320805460ff1916905551339285917ffab19bdeacf1ea13315b1da3f79a3403fe4f16793b6a03eeff9e0bbbea24fe5f9190a45050565b50805461076e906109c3565b6000825580601f1061077e575050565b601f01602090049060005260206000209081019061079c919061079f565b50565b5b808211156107b457600081556001016107a0565b5090565b634e487b7160e01b600052604160045260246000fd5b803580151581146107de57600080fd5b919050565b600080604083850312156107f657600080fd5b823567ffffffffffffffff8082111561080e57600080fd5b818501915085601f83011261082257600080fd5b813581811115610834576108346107b8565b604051601f8201601f19908116603f0116810190838211818310171561085c5761085c6107b8565b8160405282815288602084870101111561087557600080fd5b82602086016020830137600060208483010152809650505050505061089c602084016107ce565b90509250929050565b6000602082840312156108b757600080fd5b5035919050565b60005b838110156108d95781810151838201526020016108c1565b50506000910152565b600081518084526108fa8160208601602086016108be565b601f01601f19169290920160200192915050565b60808152600061092160808301876108e2565b6001600160a01b039590951660208301525060408101929092521515606090910152919050565b6000806040838503121561095b57600080fd5b8235915060208301356001600160a01b038116811461097957600080fd5b809150509250929050565b600084516109968184602089016108be565b60609490941b6bffffffffffffffffffffffff191691909301908152601481019190915260340192915050565b600181811c908216806109d757607f821691505b6020821081036109f757634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115610a4757600081815260208120601f850160051c81016020861015610a245750805b601f850160051c820191505b81811015610a4357828155600101610a30565b5050505b505050565b815167ffffffffffffffff811115610a6657610a666107b8565b610a7a81610a7484546109c3565b846109fd565b602080601f831160018114610aaf5760008415610a975750858301515b600019600386901b1c1916600185901b178555610a43565b600085815260208120601f198616915b82811015610ade57888601518255948401946001909101908401610abf565b5085821015610afc5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b604081526000610b1f60408301856108e2565b905082151560208301529392505050565b60208082526010908201526f2737ba10313ab13136329037bbb732b960811b60408201526060019056fea2646970667358221220f9a873287a60effd7137ca1e0056e6b461b1013534f0cd40351a0e6cb500070564736f6c63430008130033";
var linkReferences$1 = {
};
var deployedLinkReferences$1 = {
};
var BubbleRegistryArtifact = {
	_format: _format$1,
	contractName: contractName$1,
	sourceName: sourceName$1,
	abi: abi$1,
	bytecode: bytecode$1,
	deployedBytecode: deployedBytecode$1,
	linkReferences: linkReferences$1,
	deployedLinkReferences: deployedLinkReferences$1
};

var _format = "hh-sol-artifact-1";
var contractName = "ProofOfIntegrity";
var sourceName = "contracts/ProofOfIntegrity.sol";
var abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "nodeId",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "bytes32",
				name: "contentHash",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "address",
				name: "updater",
				type: "address"
			}
		],
		name: "DataUpdated",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "bytes32[]",
				name: "nodeIds",
				type: "bytes32[]"
			},
			{
				internalType: "bytes32[]",
				name: "contentHashes",
				type: "bytes32[]"
			}
		],
		name: "batchUpdateData",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "nodeId",
				type: "bytes32"
			}
		],
		name: "getLatestRecord",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		name: "nodeData",
		outputs: [
			{
				internalType: "bytes32",
				name: "contentHash",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "timestamp",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "updater",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "nodeId",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "contentHash",
				type: "bytes32"
			}
		],
		name: "updateData",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "nodeId",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "contentHash",
				type: "bytes32"
			}
		],
		name: "verifyData",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			},
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	}
];
var bytecode = "0x608060405234801561001057600080fd5b506104b1806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80634b04c09d1461005c5780637ada1b55146100d5578063ae870014146100ea578063e25fbc6514610164578063f63553b514610177575b600080fd5b6100ac61006a3660046102ee565b600081815260208181526040918290208251606081018452815480825260018301549382018490526002909201546001600160a01b0316930183905293909250565b6040805193845260208401929092526001600160a01b0316908201526060015b60405180910390f35b6100e86100e3366004610307565b6101af565b005b61013e6100f8366004610307565b600082815260208181526040918290208251606081018452815480825260018301549382018490526002909201546001600160a01b031693018390528314919250925092565b60408051931515845260208401929092526001600160a01b0316908201526060016100cc565b6100e86101723660046103da565b610241565b6100ac6101853660046102ee565b6000602081905290815260409020805460018201546002909201549091906001600160a01b031683565b6040805160608101825282815242602080830191825233838501818152600088815280845286902094518555925160018501559151600290930180546001600160a01b0319166001600160a01b039094169390931790925582518481529182015283917f8bfef2f2aebfe6bceb69ecae86388e8cfb858904d59c7b81295c680b664ab7e3910160405180910390a25050565b805182511461028f5760405162461bcd60e51b8152602060048201526016602482015275082e4e4c2f2e640d8cadccee8d040dad2e6dac2e8c6d60531b604482015260640160405180910390fd5b60005b82518110156102e9576102d78382815181106102b0576102b061043e565b60200260200101518383815181106102ca576102ca61043e565b60200260200101516101af565b806102e181610454565b915050610292565b505050565b60006020828403121561030057600080fd5b5035919050565b6000806040838503121561031a57600080fd5b50508035926020909101359150565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261035057600080fd5b8135602067ffffffffffffffff8083111561036d5761036d610329565b8260051b604051601f19603f8301168101818110848211171561039257610392610329565b6040529384528581018301938381019250878511156103b057600080fd5b83870191505b848210156103cf578135835291830191908301906103b6565b979650505050505050565b600080604083850312156103ed57600080fd5b823567ffffffffffffffff8082111561040557600080fd5b6104118683870161033f565b9350602085013591508082111561042757600080fd5b506104348582860161033f565b9150509250929050565b634e487b7160e01b600052603260045260246000fd5b60006001820161047457634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220d8ab4a1b53ccd5019e425c59c4b9c7922e00adc58992c763f844ae7a20c94b4264736f6c63430008130033";
var deployedBytecode = "0x608060405234801561001057600080fd5b50600436106100575760003560e01c80634b04c09d1461005c5780637ada1b55146100d5578063ae870014146100ea578063e25fbc6514610164578063f63553b514610177575b600080fd5b6100ac61006a3660046102ee565b600081815260208181526040918290208251606081018452815480825260018301549382018490526002909201546001600160a01b0316930183905293909250565b6040805193845260208401929092526001600160a01b0316908201526060015b60405180910390f35b6100e86100e3366004610307565b6101af565b005b61013e6100f8366004610307565b600082815260208181526040918290208251606081018452815480825260018301549382018490526002909201546001600160a01b031693018390528314919250925092565b60408051931515845260208401929092526001600160a01b0316908201526060016100cc565b6100e86101723660046103da565b610241565b6100ac6101853660046102ee565b6000602081905290815260409020805460018201546002909201549091906001600160a01b031683565b6040805160608101825282815242602080830191825233838501818152600088815280845286902094518555925160018501559151600290930180546001600160a01b0319166001600160a01b039094169390931790925582518481529182015283917f8bfef2f2aebfe6bceb69ecae86388e8cfb858904d59c7b81295c680b664ab7e3910160405180910390a25050565b805182511461028f5760405162461bcd60e51b8152602060048201526016602482015275082e4e4c2f2e640d8cadccee8d040dad2e6dac2e8c6d60531b604482015260640160405180910390fd5b60005b82518110156102e9576102d78382815181106102b0576102b061043e565b60200260200101518383815181106102ca576102ca61043e565b60200260200101516101af565b806102e181610454565b915050610292565b505050565b60006020828403121561030057600080fd5b5035919050565b6000806040838503121561031a57600080fd5b50508035926020909101359150565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261035057600080fd5b8135602067ffffffffffffffff8083111561036d5761036d610329565b8260051b604051601f19603f8301168101818110848211171561039257610392610329565b6040529384528581018301938381019250878511156103b057600080fd5b83870191505b848210156103cf578135835291830191908301906103b6565b979650505050505050565b600080604083850312156103ed57600080fd5b823567ffffffffffffffff8082111561040557600080fd5b6104118683870161033f565b9350602085013591508082111561042757600080fd5b506104348582860161033f565b9150509250929050565b634e487b7160e01b600052603260045260246000fd5b60006001820161047457634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220d8ab4a1b53ccd5019e425c59c4b9c7922e00adc58992c763f844ae7a20c94b4264736f6c63430008130033";
var linkReferences = {
};
var deployedLinkReferences = {
};
var ProofOfIntegrityArtifact = {
	_format: _format,
	contractName: contractName,
	sourceName: sourceName,
	abi: abi,
	bytecode: bytecode,
	deployedBytecode: deployedBytecode,
	linkReferences: linkReferences,
	deployedLinkReferences: deployedLinkReferences
};

/**
 * @typedef {Object} ChainConfig
 * @property {number} CHAIN_ID - ID della chain
 * @property {string} RPC_URL - URL del nodo RPC
 * @property {string} PROOF_OF_INTEGRITY_ADDRESS - Indirizzo del contratto ProofOfIntegrity
 * @property {string} STEALTH_ANNOUNCER_ADDRESS - Indirizzo del contratto StealthAnnouncer
 * @property {string} BUBBLE_REGISTRY_ADDRESS - Indirizzo del contratto BubbleRegistry
 */


// Esporta gli ABI dai file JSON
const STEALTH_ANNOUNCER_ABI = StealthAnnouncerArtifact.abi;
const BUBBLE_REGISTRY_ABI = BubbleRegistryArtifact.abi;
const PROOF_OF_INTEGRITY_ABI = ProofOfIntegrityArtifact.abi;

// Configurazioni per diverse chain
const chainConfigs = {
  localhost: {
    CHAIN_ID: 31337,
    RPC_URL: "http://127.0.0.1:8545",
    PROOF_OF_INTEGRITY_ADDRESS: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
    STEALTH_ANNOUNCER_ADDRESS: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    BUBBLE_REGISTRY_ADDRESS: "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0"
  },
  polygon: {
    CHAIN_ID: 137,
    RPC_URL: "https://polygon-mainnet.g.alchemy.com/v2/yjhjIoJ3o_at8ALT7nCJtFtjdqFpiBdx",
    PROOF_OF_INTEGRITY_ADDRESS: "0x8515fa00a00A5483a3485526c7aD1f44E2779321",
    STEALTH_ANNOUNCER_ADDRESS: "0xD0CDbD17E4f2DDCE27B51721095048302768434f",
    BUBBLE_REGISTRY_ADDRESS: "0xc70DC231B9690D9dA988f6D4E518356eE9e45cd9"
  }
};

/** @type {boolean} */
const isLocalEnvironment = typeof process !== 'undefined' && process.env.NODE_ENV === 'development';

/**
 * Ottiene le configurazioni degli indirizzi per una specifica chain
 * @param {string} [chain='localhost'] - Nome della chain
 * @returns {ChainConfig} Configurazione degli indirizzi per la chain specificata
 * @throws {Error} Se la configurazione della chain non viene trovata
 */
function getAddressesForChain(chain = 'localhost') {
  const config = chainConfigs[chain];
  if (!config) {
    throw new Error(`Chain configuration not found for: ${chain}`);
  }
  return config;
}

// Esporta gli indirizzi di default (localhost)
const {
  PROOF_OF_INTEGRITY_ADDRESS,
  STEALTH_ANNOUNCER_ADDRESS,
  BUBBLE_REGISTRY_ADDRESS
} = getAddressesForChain('localhost');

/**
 * @typedef {Object|string} KeyPair
 * @property {string} [epriv] - Private encryption key
 * @property {string} [epub] - Public encryption key
 * @property {string} [pub] - Optional public key
 * @property {string} [priv] - Optional private key
 */

/**
 * Encrypts data using SEA encryption
 * @param {string|Object} data - Data to encrypt
 * @param {KeyPair} keypair - Keypair for encryption
 * @returns {Promise<string>} Encrypted data
 * @throws {Error} If encryption fails
 */
async function encrypt(data, keypair) {
  try {
    const dataToEncrypt = typeof data === 'object' ? JSON.stringify(data) : data;
    const encrypted = await SEA$1.encrypt(dataToEncrypt, keypair);
    if (!encrypted) {
      throw new Error('Encryption failed');
    }
    return encrypted;
  } catch (error) {
    console.error('Encryption error:', error);
    throw error;
  }
}

/**
 * Decrypts data using SEA decryption
 * @param {string} data - Encrypted data to decrypt
 * @param {KeyPair} keypair - Keypair for decryption
 * @returns {Promise<string|Object>} Decrypted data
 * @throws {Error} If decryption fails
 */
async function decrypt(data, keypair) {
  try {
    const decrypted = await SEA$1.decrypt(data, keypair);
    if (!decrypted) {
      console.log("Decryption returned null");
      throw new Error('Decryption failed');
    }
    try {
      return typeof decrypted === 'string' ? JSON.parse(decrypted) : decrypted;
    } catch {
      return decrypted;
    }
  } catch (error) {
    console.error('Decryption error:', error);
    console.error('Data:', data);
    console.error('Keypair:', {
      hasEpriv: !!keypair?.epriv,
      hasEpub: !!keypair?.epub,
      hasPub: !!keypair?.pub,
      hasPriv: !!keypair?.priv
    });
    throw error;
  }
}

/**
 * Derives a shared secret key between two keypairs
 * @param {string} recipientEpub - Recipient's public encryption key
 * @param {KeyPair} senderKeypair - Sender's keypair
 * @returns {Promise<string>} Derived shared key
 * @throws {Error} If key derivation fails
 */
async function deriveSharedKey(recipientEpub, senderKeypair) {
  try {
    if (!recipientEpub || !senderKeypair || !senderKeypair.epriv) {
      throw new Error('Invalid parameters for shared key derivation');
    }
    const sharedKey = await SEA$1.secret(recipientEpub, senderKeypair);
    if (!sharedKey) {
      throw new Error('Failed to derive shared key');
    }
    return sharedKey;
  } catch (error) {
    console.error('Error deriving shared key:', error);
    throw error;
  }
}

// @ts-check


/** 
 * Extended Gun with additional methods
 * @typedef {import('gun').IGun & { 
 *   get: (path: string) => any,
 *   verifySignature: (message: string, signature: string) => Promise<string>,
 *   put: (data: any) => void,
 *   set: (data: any) => void,
 *   map: () => any,
 *   once: (callback: (data: any, key: string) => void) => void
 * }} ExtendedGun 
 */

/**
 * @typedef {Object} StealthAddressResult
 * @property {string} stealthPrivateKey - The private key of the stealth address
 * @property {string} stealthAddress - The stealth address
 * @property {ethers.Wallet} wallet - The stealth wallet
 */

/**
 * @typedef {Object} StealthAddressGenerationResult
 * @property {string} stealthAddress - The generated stealth address
 * @property {string} senderPublicKey - The public key of the sender
 * @property {string} spendingPublicKey - The spending public key of the recipient
 */

/**
 * @typedef {Object} StealthPaymentOptions
 * @property {boolean} [onChain] - If true, announce on-chain, otherwise off-chain
 * @property {string} [chain] - The chain to announce on (if onChain=true)
 */

/**
 * @typedef {Object} StealthPaymentResult
 * @property {ethers.Wallet} wallet - The recovered wallet
 * @property {string} address - The recovered address
 */

/**
 * @typedef {Object} PublicKeysResult
 * @property {string} viewingPublicKey - The viewing public key
 * @property {string} spendingPublicKey - The spending public key
 */

/**
 * Configuration for StealthChain
 * @typedef {Object} StealthChainConfig
 * @property {string} [contractAddress] - Address of deployed StealthAnnouncer contract
 * @property {string} [abi] - ABI of the contract (optional, defaults to STEALTH_ANNOUNCER_ABI)
 */

class StealthChain {
  /** @type {ExtendedGun} */
  gun;
  /** @type {string | undefined} */
  contractAddress;
  /** @type {any} */
  contractAbi;

  /**
   * Creates a new StealthChain instance
   * @param {ExtendedGun} gun - Gun instance
   * @param {StealthChainConfig} [config] - Optional configuration
   */
  constructor(gun, config = {}) {
    this.gun = gun;
    this.contractAddress = config.contractAddress;
    this.contractAbi = config.abi || STEALTH_ANNOUNCER_ABI;
  }

  /**
   * Gets contract instance for the specified chain
   * @param {string} chain - Chain identifier
   * @returns {Promise<ethers.Contract>} Contract instance
   */
  async getContract(chain) {
    const signer = await getSigner();
    const address = this.contractAddress || getContractAddresses(chain).STEALTH_ANNOUNCER_ADDRESS;
    return new ethers.ethers.Contract(address, this.contractAbi, signer);
  }

  /**
   * Derives a stealth address from shared secret and spending public key
   * @param {string} sharedSecret - The shared secret
   * @param {string} spendingPublicKey - The spending public key
   * @returns {StealthAddressResult} The derived stealth address details
   */
  deriveStealthAddress(sharedSecret, spendingPublicKey) {
    try {
      // Base64 to hex conversion function
      const base64ToHex = base64 => {
        // Remove everything after the dot (if present)
        const cleanBase64 = base64.split('.')[0];
        // Remove 0x prefix if present
        const withoutPrefix = cleanBase64.replace('0x', '');
        // Convert from base64 to hex
        const raw = atob(withoutPrefix.replace(/-/g, '+').replace(/_/g, '/'));
        let hex = '';
        for (let i = 0; i < raw.length; i++) {
          const hexByte = raw.charCodeAt(i).toString(16);
          hex += hexByte.length === 2 ? hexByte : '0' + hexByte;
        }
        return '0x' + hex;
      };
      console.log("Input values:", {
        sharedSecret,
        spendingPublicKey
      });

      // Convert both values to hex
      const sharedSecretHex = base64ToHex(sharedSecret);
      const spendingPublicKeyHex = base64ToHex(spendingPublicKey);
      console.log("Converted values:", {
        sharedSecretHex,
        spendingPublicKeyHex
      });

      // Generate stealth private key
      const stealthPrivateKey = ethers.ethers.keccak256(ethers.ethers.concat([ethers.ethers.getBytes(sharedSecretHex), ethers.ethers.getBytes(spendingPublicKeyHex)]));

      // Create stealth wallet
      const stealthWallet = new ethers.ethers.Wallet(stealthPrivateKey);
      console.log("Generated stealth values:", {
        stealthPrivateKey,
        stealthAddress: stealthWallet.address
      });
      return {
        stealthPrivateKey,
        stealthAddress: stealthWallet.address,
        wallet: stealthWallet
      };
    } catch (error) {
      console.error("Error in deriveStealthAddress:", error);
      throw error;
    }
  }

  /**
   * Generates a stealth address for a recipient
   * @param {string} recipientAddress - The recipient's address
   * @param {string} signature - The signature
   * @param {Object} options - Additional options
   * @returns {Promise<StealthAddressGenerationResult>} The generated stealth address details
   */
  async generateStealthAddress(recipientAddress, signature, options = {}) {
    try {
      console.log("\nGenerating stealth address...");

      // Get recipient's public keys
      const recipientData = await this.gun.get("gun-eth").get("users").get(recipientAddress).get("publicKeys").then();
      if (!recipientData?.viewingPublicKey || !recipientData?.spendingPublicKey) {
        throw new Error("Recipient's public keys not found");
      }
      console.log("Retrieved recipient keys:", {
        viewing: recipientData.viewingPublicKey.slice(0, 20) + "...",
        spending: recipientData.spendingPublicKey.slice(0, 20) + "..."
      });

      // Get sender's keys
      const senderAddress = await this.gun.verifySignature(MESSAGE_TO_SIGN, signature);
      const password = generatePassword(signature);
      const senderData = await this.gun.get("gun-eth").get("users").get(senderAddress).then();
      if (!senderData?.s_pair) {
        throw new Error("Sender's keys not found");
      }

      // Decrypt sender's spending pair
      let spendingKeyPair;
      try {
        const decryptedData = await decrypt(senderData.s_pair, password);
        spendingKeyPair = typeof decryptedData === 'string' ? JSON.parse(decryptedData) : decryptedData;
      } catch (error) {
        console.error("Error decrypting spending pair:", error);
        throw new Error("Unable to decrypt spending pair");
      }

      // Generate shared secret using SEA ECDH
      const sharedSecret = await deriveSharedKey(recipientData.viewingPublicKey, spendingKeyPair);
      if (!sharedSecret) {
        throw new Error("Unable to generate shared secret");
      }
      console.log("Generated shared secret");

      // Derive stealth address
      const {
        stealthAddress
      } = this.deriveStealthAddress(sharedSecret, recipientData.spendingPublicKey);
      return {
        stealthAddress,
        senderPublicKey: spendingKeyPair.epub,
        spendingPublicKey: recipientData.spendingPublicKey
      };
    } catch (error) {
      console.error("Error generating stealth address:", error);
      throw error;
    }
  }

  /**
   * Announces a stealth payment on-chain or off-chain
   * @param {string} stealthAddress - The stealth address of the recipient
   * @param {string} senderPublicKey - The sender's public key
   * @param {string} spendingPublicKey - The recipient's spending public key
   * @param {string} signature - The sender's signature
   * @param {StealthPaymentOptions} options - Additional options
   * @returns {Promise<{stealthAddress: string, senderPublicKey: string, spendingPublicKey: string, timestamp: number, source: string}>}
   */
  async announceStealthPayment(stealthAddress, senderPublicKey, spendingPublicKey, signature, options = {}) {
    try {
      const {
        chain = 'localhost',
        onChain = false
      } = options;

      // Verifica la firma
      await this.gun.verifySignature(MESSAGE_TO_SIGN, signature);
      if (onChain) {
        const contract = await this.getContract(chain);

        // Ottieni la devFee dal contratto
        let devFee;
        try {
          devFee = await contract.devFee();
        } catch (error) {
          console.warn("Errore nel leggere devFee, uso il valore di default:", error);
          devFee = ethers.ethers.parseEther("0.0001"); // 0.0001 ETH come default
        }

        // Esegui l'annuncio on-chain
        const tx = await contract.announcePayment(senderPublicKey, spendingPublicKey, stealthAddress, {
          value: devFee
        });
        await tx.wait();
        console.log("Payment announced on-chain, tx:", tx.hash);
      }

      // Salva anche off-chain
      const announcement = {
        stealthAddress,
        senderPublicKey,
        spendingPublicKey,
        timestamp: Date.now(),
        source: onChain ? 'both' : 'off-chain'
      };
      this.gun.get('gun-eth').get('stealth').get('announcements').set(announcement);
      return announcement;
    } catch (error) {
      console.error("Error announcing stealth payment:", error);
      throw error;
    }
  }

  /**
   * Retrieves stealth payments
   * @param {string} signature - The signature
   * @param {Object} options - Additional options
   * @returns {Promise<Array>} The list of stealth payments
   */
  async getStealthPayments(signature, options = {}) {
    try {
      const payments = [];

      // Set default options
      const defaultOptions = {
        source: 'both',
        chain: 'localhost' // Default to localhost
      };
      options = {
        ...defaultOptions,
        ...options
      };
      if (options.source === 'onChain' || options.source === 'both') {
        const contract = await this.getContract(options.chain);
        const totalAnnouncements = await contract.getAnnouncementsCount();
        const totalCount = Number(totalAnnouncements.toString());
        if (totalCount > 0) {
          const batchSize = 100;
          const lastIndex = totalCount - 1;
          for (let i = 0; i <= lastIndex; i += batchSize) {
            const toIndex = Math.min(i + batchSize - 1, lastIndex);
            const batch = await contract.getAnnouncementsInRange(i, toIndex);
            for (const announcement of batch) {
              try {
                // Verify announcement is valid
                if (!announcement || !announcement.stealthAddress) continue;

                // Format announcement
                const formattedAnnouncement = {
                  stealthAddress: announcement.stealthAddress,
                  senderPublicKey: announcement.senderPublicKey,
                  spendingPublicKey: announcement.spendingPublicKey,
                  timestamp: Number(announcement.timestamp || 0)
                };

                // Try to recover funds
                try {
                  const recoveredWallet = await this.recoverStealthFunds(formattedAnnouncement.stealthAddress, formattedAnnouncement.senderPublicKey, signature, formattedAnnouncement.spendingPublicKey);

                  // If recovery succeeds, add announcement
                  payments.push({
                    ...formattedAnnouncement,
                    source: 'onChain',
                    wallet: recoveredWallet
                  });
                } catch (e) {
                  // If recovery fails, announcement wasn't for this user
                  console.log(`Skipping announcement: ${e.message}`);
                  continue;
                }
              } catch (e) {
                console.log(`Error processing announcement: ${e.message}`);
                continue;
              }
            }
          }
        }
      }
      if (options.source === 'offChain' || options.source === 'both') {
        const offChainPayments = await new Promise(resolve => {
          const p = [];
          this.gun.get("gun-eth").get("stealth-payments").map().once((payment, id) => {
            if (payment?.stealthAddress) {
              p.push({
                ...payment,
                id,
                source: 'offChain'
              });
            }
          });
          setTimeout(() => resolve(p), 2000);
        });

        // Filter and process off-chain payments
        for (const payment of offChainPayments) {
          try {
            const recoveredWallet = await this.recoverStealthFunds(payment.stealthAddress, payment.senderPublicKey, signature, payment.spendingPublicKey);
            payments.push({
              ...payment,
              wallet: recoveredWallet
            });
          } catch (e) {
            console.log(`Skipping off-chain payment: ${e.message}`);
            continue;
          }
        }
      }
      return payments;
    } catch (error) {
      console.error("Error retrieving stealth payments:", error);
      throw error;
    }
  }

  /**
   * Recovers stealth funds
   * @param {string} stealthAddress - The stealth address
   * @param {string} senderPublicKey - The sender's public key
   * @param {string} signature - The signature
   * @param {string} spendingPublicKey - The spending public key
   * @returns {Promise<StealthPaymentResult>} The recovered funds details
   */
  async recoverStealthFunds(stealthAddress, senderPublicKey, signature, spendingPublicKey) {
    try {
      const gun = this.gun;
      const password = generatePassword(signature);

      // Get own key pairs
      const myAddress = await verifySignature(MESSAGE_TO_SIGN, signature);
      const encryptedData = await gun.get("gun-eth").get("users").get(myAddress).then();
      if (!encryptedData?.v_pair) {
        throw new Error("Keys not found");
      }

      // Decrypt viewing pair
      let viewingKeyPair;
      try {
        const decryptedViewingData = await decrypt(encryptedData.v_pair, password);
        viewingKeyPair = typeof decryptedViewingData === 'string' ? JSON.parse(decryptedViewingData) : decryptedViewingData;
      } catch (error) {
        throw new Error("Unable to decrypt keys");
      }

      // Generate shared secret using SEA ECDH
      const sharedSecret = await SEA$1.secret(senderPublicKey, viewingKeyPair);
      if (!sharedSecret) {
        throw new Error("Unable to generate shared secret");
      }
      const {
        wallet,
        stealthAddress: recoveredAddress
      } = this.deriveStealthAddress(sharedSecret, spendingPublicKey);

      // Verify address matches
      if (recoveredAddress.toLowerCase() !== stealthAddress.toLowerCase()) {
        throw new Error("Recovered stealth address does not match");
      }
      return {
        wallet,
        address: recoveredAddress
      };
    } catch (error) {
      console.error("Error recovering stealth funds:", error);
      throw error;
    }
  }

  /**
   * Publishes user's stealth keys
   * @param {string} signature - The signature
   * @returns {Promise<PublicKeysResult>} The published public keys
   */
  async publishStealthKeys(signature) {
    try {
      // Verifica la firma
      const signer = await getSigner();
      if (!signer) {
        throw new Error("No signer available");
      }
      const address = await signer.getAddress();
      const recoveredAddress = await verifySignature(MESSAGE_TO_SIGN, signature);
      if (!recoveredAddress || recoveredAddress.toLowerCase() !== address.toLowerCase()) {
        throw new Error("Invalid signature");
      }

      // Genera la password dal signature
      const password = generatePassword(signature);
      if (!password) {
        throw new Error("No encryption key.");
      }

      // Genera key pairs
      const viewingKeyPair = await SEA$1.pair();
      const spendingKeyPair = await SEA$1.pair();

      // Encrypt key pairs
      const encryptedViewingPair = await SEA$1.encrypt(JSON.stringify(viewingKeyPair), password);
      const encryptedSpendingPair = await SEA$1.encrypt(JSON.stringify(spendingKeyPair), password);

      // Save public keys and encrypted pairs
      await this.gun.get('gun-eth').get('users').get(address).put({
        publicKeys: {
          viewingPublicKey: viewingKeyPair.epub,
          spendingPublicKey: spendingKeyPair.epub
        },
        v_pair: encryptedViewingPair,
        s_pair: encryptedSpendingPair
      });
      return {
        viewingPublicKey: viewingKeyPair.epub,
        spendingPublicKey: spendingKeyPair.epub
      };
    } catch (error) {
      console.error("Error publishing stealth keys:", error);
      throw error;
    }
  }
}

// @ts-nocheck
let contractAddresses$2 = {
  PROOF_OF_INTEGRITY_ADDRESS,
  STEALTH_ANNOUNCER_ADDRESS
};

/**
 * @typedef {import('ethers').Eip1193Provider} EthereumProvider
 */

/** @typedef {Window & { ethereum?: EthereumProvider }} WindowWithEthereum */

const window$1 = globalThis.window;

// Singleton for signer management
class SignerManager {
  static instance = null;
  static provider = null;
  static signer = null;
  static rpcUrl = "";
  static privateKey = "";
  static getInstance() {
    if (!SignerManager.instance) {
      SignerManager.instance = new SignerManager();
    }
    return SignerManager.instance;
  }
  static async getSigner() {
    if (SignerManager.signer) {
      return SignerManager.signer;
    }
    if (SignerManager.rpcUrl !== "" && SignerManager.privateKey !== "") {
      SignerManager.provider = new ethers.ethers.JsonRpcProvider(SignerManager.rpcUrl);
      const wallet = new ethers.ethers.Wallet(SignerManager.privateKey, SignerManager.provider);
      // Create a proxy instead of modifying the wallet directly
      SignerManager.signer = new Proxy(wallet, {
        get(target, prop) {
          if (prop === 'address') {
            return target.address;
          }
          if (prop === 'privateKey') {
            return SignerManager.privateKey;
          }
          return target[prop];
        }
      });
      return SignerManager.signer;
    }
    if (typeof window$1 !== "undefined" && window$1?.ethereum) {
      /** @type {WindowWithEthereum} */
      const windowWithEthereum = window$1;
      await windowWithEthereum.ethereum?.request({
        method: "eth_requestAccounts"
      });
      const browserProvider = new ethers.ethers.BrowserProvider(windowWithEthereum.ethereum);
      const signer = await browserProvider.getSigner();
      // Create a proxy for the browser signer as well
      SignerManager.signer = new Proxy(signer, {
        get(target, prop) {
          if (prop === 'address') {
            return target.getAddress();
          }
          if (prop === 'privateKey') {
            return '';
          }
          return target[prop];
        }
      });
      return SignerManager.signer;
    }
    throw new Error("No valid Ethereum provider found. Call setSigner first.");
  }
  static setSigner(newRpcUrl, newPrivateKey) {
    SignerManager.rpcUrl = newRpcUrl;
    SignerManager.privateKey = newPrivateKey;
    SignerManager.provider = new ethers.ethers.JsonRpcProvider(newRpcUrl);
    const wallet = new ethers.ethers.Wallet(newPrivateKey, SignerManager.provider);
    // Create a proxy for the new signer
    SignerManager.signer = new Proxy(wallet, {
      get(target, prop) {
        if (prop === 'address') {
          return target.address;
        }
        if (prop === 'privateKey') {
          return SignerManager.privateKey;
        }
        return target[prop];
      }
    });
    console.log("Signer configured with address:", wallet.address);
    return SignerManager.instance;
  }
}
function generateRandomId() {
  return ethers.ethers.hexlify(ethers.ethers.randomBytes(32));
}
function getContractAddresses(chain = 'localhost') {
  if (isLocalEnvironment && contractAddresses$2) {
    console.log('Using local contract addresses:', contractAddresses$2);
    return contractAddresses$2;
  }
  const chainConfig = getAddressesForChain(chain);
  console.log(`Using ${chain} configuration:`, chainConfig);
  return {
    PROOF_OF_INTEGRITY_ADDRESS: chainConfig.PROOF_OF_INTEGRITY_ADDRESS,
    STEALTH_ANNOUNCER_ADDRESS: chainConfig.STEALTH_ANNOUNCER_ADDRESS
  };
}
function setSigner$1(newRpcUrl, newPrivateKey) {
  return SignerManager.setSigner(newRpcUrl, newPrivateKey);
}
async function getSigner$1(chain = 'localhost') {
  return SignerManager.getSigner();
}

// @ts-check


/**
 * Result of proof verification
 * @typedef {Object} ProofResult
 * @property {boolean} isValid - Whether the data is valid
 * @property {number} timestamp - Verification timestamp
 * @property {string} updater - Address of last update
 */

/**
 * Latest record
 * @typedef {Object} LatestRecord
 * @property {string} contentHash - Content hash
 * @property {number} timestamp - Last update timestamp
 * @property {string} updater - Address of last updater
 */

/**
 * Callback for proof operations
 * @typedef {Object} ProofCallback
 * @property {boolean} [ok] - Whether operation was successful
 * @property {string} [message] - Success/error message
 * @property {string} [err] - Error message
 * @property {number} [timestamp] - Operation timestamp
 * @property {string} [updater] - Updater address
 * @property {LatestRecord} [latestRecord] - Latest record
 * @property {string} [nodeId] - Created node ID
 * @property {string} [txHash] - Transaction hash
 */

/**
 * Options for proof transactions
 * @typedef {Object} ProofOptions
 * @property {number} [gasLimit] - Gas limit for transaction
 * @property {number} [gasPrice] - Gas price
 */

/** 
 * Extended Gun with additional methods
 * @typedef {import('gun').IGun & { get: (path: string) => any }} ExtendedGun 
 */

/**
 * Extended transaction with additional methods
 * @typedef {import('ethers').ContractTransaction & { wait: () => Promise<any>, hash: string }} ExtendedTransaction 
 */

/**
 * Configuration for ProofChain
 * @typedef {Object} ProofChainConfig
 * @property {string} [contractAddress] - Address of deployed ProofOfIntegrity contract
 * @property {string} [abi] - ABI of the contract (optional, defaults to PROOF_OF_INTEGRITY_ABI)
 */

/**
 * Class for handling blockchain proof of integrity
 * @class
 */
class ProofChain {
  /**
   * Creates a new ProofChain instance
   * @param {Gun} gun - Gun instance
   * @param {ProofChainConfig} [config] - Optional configuration
   */
  constructor(gun, config = {}) {
    /** @type {ExtendedGun} */
    this.gun = /** @type {ExtendedGun} */gun;
    this.contractAddress = config.contractAddress;
    this.contractAbi = config.abi || PROOF_OF_INTEGRITY_ABI;
  }

  /**
   * Gets contract instance for the specified chain
   * @param {string} chain - Chain identifier
   * @returns {Promise<Contract>} Contract instance
   */
  async getContract(chain) {
    const signer = await getSigner$1(chain);
    const address = this.contractAddress || getContractAddresses(chain).PROOF_OF_INTEGRITY_ADDRESS;
    return new ethers.ethers.Contract(address, this.contractAbi, signer);
  }

  /**
   * Converts an ID to bytes32
   * @param {ethers.BytesLike} id - ID to convert
   * @returns {string} ID converted to bytes32
   */
  convertToBytes32(id) {
    if (typeof id === "string") {
      // If id is already in hex format with 0x
      if (id.startsWith("0x")) {
        return ethers.ethers.zeroPadValue(id, 32);
      }
      // If it's a hex string without 0x, add 0x
      if (/^[0-9a-fA-F]{64}$/.test(id)) {
        return ethers.ethers.zeroPadValue(`0x${id}`, 32);
      }
      // Otherwise encode string as UTF8 and calculate keccak256
      return ethers.ethers.keccak256(ethers.ethers.toUtf8Bytes(id));
    }
    // If already BytesLike, ensure correct length
    return ethers.ethers.zeroPadValue(id, 32);
  }

  /**
   * Verifies data on-chain
   * @param {string} chain - Chain identifier
   * @param {string} nodeId - Node ID to verify
   * @param {string} contentHash - Content hash to verify
   * @returns {Promise<ProofResult>} Verification result
   */
  async verifyOnChain(chain, nodeId, contentHash) {
    try {
      const contract = await this.getContract(chain);
      const nodeIdBytes = this.convertToBytes32(nodeId);

      // If no contentHash, get latest record
      if (!contentHash) {
        const record = await this.getLatestRecord(chain, nodeId);
        contentHash = record.contentHash;
      }

      // Ensure contentHash is in correct format
      const contentHashBytes = typeof contentHash === "string" && contentHash.startsWith("0x") ? ethers.ethers.zeroPadValue(contentHash, 32) : ethers.ethers.zeroPadValue(`0x${contentHash}`, 32);
      const [isValid, timestamp, updater] = await contract.verifyData(nodeIdBytes, contentHashBytes);
      return {
        isValid,
        timestamp: Number(timestamp),
        updater
      };
    } catch (error) {
      console.error("Error verifying data:", error);
      throw error;
    }
  }

  /**
   * Writes data on-chain
   * @param {string} chain - Chain identifier
   * @param {string} nodeId - Node ID to write
   * @param {string} contentHash - Content hash to write
   * @param {Object} options - Transaction options
   * @returns {Promise<ExtendedTransaction>} Resulting transaction
   */
  async writeOnChain(chain, nodeId, contentHash, options = {}) {
    try {
      const nodeIdBytes = this.convertToBytes32(nodeId);
      const contentHashBytes = typeof contentHash === "string" && contentHash.startsWith("0x") ? ethers.ethers.zeroPadValue(contentHash, 32) : ethers.ethers.zeroPadValue(`0x${contentHash}`, 32);
      const contract = await this.getContract(chain);
      const tx = await contract.updateData(nodeIdBytes, contentHashBytes, options);
      return tx;
    } catch (error) {
      console.error("Error writing to chain:", error);
      throw error;
    }
  }

  /**
   * Gets the latest record
   * @param {string} chain - Chain name
   * @param {ethers.BytesLike} nodeId - Node ID
   * @returns {Promise<LatestRecord>} Latest record
   */
  async getLatestRecord(chain, nodeId) {
    const contract = await this.getContract(chain);
    const nodeIdBytes = this.convertToBytes32(nodeId);
    const [contentHash, timestamp, updater] = await contract.getLatestRecord(nodeIdBytes);
    return {
      contentHash,
      timestamp,
      updater
    };
  }

  /**
   * Verifies or writes data with proof of integrity
   * @param {string} chain - Chain name
   * @param {string} nodeId - Node ID (for verification)
   * @param {object} data - Data to write
   * @param {function} callback - Callback function
   * @param {object} options - Transaction options
   * @returns {Promise<this>} Current instance
   */
  async proof(chain, nodeId, data, callback, options = {}) {
    try {
      if (!data) {
        // Verify
        const result = await this.verifyOnChain(chain, nodeId, null);
        const latestRecord = await this.getLatestRecord(chain, nodeId);
        callback({
          ok: result.isValid,
          ...result,
          latestRecord: {
            contentHash: latestRecord.contentHash,
            timestamp: Number(latestRecord.timestamp),
            updater: latestRecord.updater
          }
        });

        // Verify current data in GunDB
        this.gun.get(nodeId).once(gunData => {
          if (gunData) {
            console.log("\n🔄 Re-analyzing current data state...");
            const currentData = {
              ...gunData
            };
            delete currentData._;
            const storedHash = currentData._contentHash;
            delete currentData._contentHash;
            const currentDataString = JSON.stringify(currentData);
            const currentHash = ethers.ethers.keccak256(ethers.ethers.toUtf8Bytes(currentDataString));
            console.log("Current data state:", currentData);
            console.log("Calculated new hash:", currentHash);
            console.log("Original stored hash:", storedHash);
            if (currentHash !== storedHash) {
              console.log("\n⚠️ WARNING: Data has been tampered!");
            } else {
              console.log("\n✅ Data integrity check passed: No tampering detected");
            }
          }
        });
        return this;
      }

      // Calculate content hash
      const dataString = JSON.stringify(data);
      const contentHash = ethers.ethers.keccak256(ethers.ethers.toUtf8Bytes(dataString));

      // If no nodeId, generate a new one
      if (!nodeId) {
        nodeId = generateRandomId();
      }

      // Save data to GUN
      data._contentHash = contentHash;
      this.gun.get(nodeId).put(data);

      // Write hash to blockchain
      const tx = await this.writeOnChain(chain, nodeId, contentHash, options);
      await tx.wait();
      callback({
        ok: true,
        nodeId,
        txHash: tx.hash
      });
    } catch (error) {
      callback({
        err: error.message
      });
    }
    return this;
  }

  /**
   * Extends Gun with proof methods
   * @param {typeof Gun} Gun - Gun constructor
   */
  static extendGun(Gun) {
    // @ts-ignore
    Gun.chain.proof = function (/** @type {string} */chain, /** @type {string} */nodeId, /** @type {any} */data, /** @type {Function} */callback, /** @type {ProofChainConfig & any} */options) {
      // @ts-ignore
      const proofChain = new ProofChain(this, options);
      return proofChain.proof(chain, nodeId, data, callback, options);
    };
  }
}

// Importazioni condizionali per ambiente Node.js
let contractAddresses$1 = {};
(async () => {
  if (typeof window === 'undefined') {
    try {
      // Ambiente Node.js
      const url = await import('url');
      const path = await import('path');
      const fs = await import('fs');
      const fileURLToPath = url.fileURLToPath;
      const dirname = path.dirname;
      const join = path.join;
      const __filename = fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('gun-eth.cjs', document.baseURI).href)));
      const __dirname = dirname(__filename);
      const rawdata = fs.readFileSync(join(__dirname, '../config/contract-address.json'), 'utf8');
      Object.assign(contractAddresses$1, JSON.parse(rawdata));
      console.log("Loaded contract addresses:", contractAddresses$1);
    } catch (error) {
      console.warn("Warning: contract-address.json not found or invalid");
    }
  }
})();
const LOCAL_CONFIG = {
  STEALTH_ANNOUNCER_ADDRESS: contractAddresses$1.StealthAnnouncer || '0x5FbDB2315678afecb367f032d93F642f64180aa3',
  PROOF_OF_INTEGRITY_ADDRESS: contractAddresses$1.ProofOfIntegrity || '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',
  BUBBLE_REGISTRY_ADDRESS: contractAddresses$1.BubbleRegistry || '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0',
  RPC_URL: 'http://127.0.0.1:8545',
  CHAIN_ID: 31337
};

// @ts-check


/**
 * @typedef {import('gun').IGunChain<any, any, any, any>} IGunChain
 * @typedef {import('gun').IGunInstance} IGunInstance
 * @typedef {import('gun').IGun} IGun
 * @typedef {import('gun').GunOptions} GunOptions
 * @typedef {import('gun').GunSchema} GunSchema
 * @typedef {import('gun').GunHookCallbackCreate} GunHookCallbackCreate
 * @typedef {import('gun').GunHookCallbackOpt} GunHookCallbackOpt
 */

/**
 * @typedef {Object} GunMethods
 * @property {(path: string) => IGunInstance} get - Get method
 * @property {(data: any) => IGunInstance} put - Put method
 * @property {(data: any) => IGunInstance} set - Set method
 * @property {() => IGunInstance} map - Map method
 * @property {() => IGunInstance} back - Back method
 * @property {() => IGunInstance} off - Off method
 * @property {{
 *   (event: "create", callback: GunHookCallbackCreate): void;
 *   (event: "opt", callback: GunHookCallbackOpt): void;
 *   (event: string, callback: Function): IGunInstance;
 * }} on - On method
 * @property {(callback: (data: any, key: string) => void) => IGunInstance} once - Once method
 */

/**
 * @typedef {Object} GunBase
 * @property {Object} state - Gun state
 * @property {IGunChain & IGunInstance} chain - Gun chain
 * @property {Object} SEA - Gun SEA
 * @property {(message: string, signature: string) => Promise<string>} verifySignature - Verify signature method
 * @property {Object} _ - Gun internal properties
 * @property {Object} user - Gun user instance
 * @property {Object} opt - Gun options
 */

/**
 * @typedef {GunBase & GunMethods & {
 *   (options?: GunOptions): IGunInstance;
 *   new (options?: GunOptions): IGunInstance;
 * }} GunExtended
 */

/**
 * @typedef {Object} StealthMethodsBase
 * @property {function(this: IGunInstance, string, string, Object): Promise<any>} generateStealthAddress
 * @property {function(this: IGunInstance, string, string, string, string, Object): Promise<{stealthAddress: string, senderPublicKey: string, spendingPublicKey: string, timestamp: number, source: string}>} announceStealthPayment
 * @property {function(this: IGunInstance, string, Object): Promise<Array<any>>} getStealthPayments
 * @property {function(this: IGunInstance, string, string, string, string): Promise<any>} recoverStealthFunds
 * @property {function(this: IGunInstance, string): Promise<any>} publishStealthKeys
 * @property {function(this: IGunInstance, string, ...any[]): Promise<any>} stealth
 * @property {function(this: IGunInstance, function(any): void): any} monitorStealthEvents
 */

/**
 * @typedef {Object} ExtendedSigner
 * @property {string} address - Ethereum address
 * @property {string} privateKey - Private key
 * @property {function(string): Promise<string>} signMessage - Signs a message
 * @property {function(): Promise<string>} getAddress - Gets the signer address
 * @property {Object} provider - Provider instance
 */

/**
 * @typedef {Object} BaseMethods
 * @property {string} MESSAGE_TO_SIGN
 * @property {function} setSigner
 * @property {function} getSigner
 * @property {function} verifySignature
 * @property {function} generatePassword
 * @property {function} createSignature
 * @property {function} createAndStoreEncryptedPair
 * @property {function} getAndDecryptPair
 * @property {function} ethToGunAccount
 * @property {function} gunToEthAccount
 * @property {function} getAddressesForChain
 */

/**
 * @typedef {StealthMethodsBase & IGunInstance} StealthMethods
 */

/**
 * @typedef {Object} ExtendedGunBase
 * @property {Object} state - Gun state
 * @property {IGunChain & IGunInstance} chain - Gun chain
 * @property {Object} SEA - Gun SEA
 * @property {(path: string) => any} get - Get method
 * @property {(data: any) => void} put - Put method
 * @property {(data: any) => void} set - Set method
 * @property {() => any} map - Map method
 * @property {(event: string, callback: Function) => any} on - On method
 * @property {(callback: (data: any, key: string) => void) => void} once - Once method
 * @property {(message: string, signature: string) => Promise<string>} verifySignature - Verify signature method
 * @property {Object} _ - Gun internal properties
 * @property {Object} user - Gun user instance
 * @property {Object} opt - Gun options
 */

/**
 * @typedef {ExtendedGunBase & IGun} ExtendedGun
 */

/**
 * @typedef {ExtendedGun & IGunInstance} FullGunInstance
 */

/**
 * @typedef {Object} GunHookCallbacks
 * @property {function} create - Create callback
 * @property {function} put - Put callback
 * @property {function} get - Get callback
 * @property {function} opt - Opt callback
 */

const MESSAGE_TO_SIGN = "Access GunDB with Ethereum";
let contractAddresses = {
  PROOF_OF_INTEGRITY_ADDRESS,
  STEALTH_ANNOUNCER_ADDRESS
};

// =============================================
// INITIALIZATION
// =============================================

async function initializeTextEncoder() {
  if (typeof window === "undefined") {
    const util = await import('util');
    global.TextEncoder = util.TextEncoder;
    global.TextDecoder = util.TextDecoder;
  }
}
async function initialize(chain = 'localhost') {
  await initializeTextEncoder();
  contractAddresses = isLocalEnvironment ? getContractAddresses(chain) : getContractAddresses(chain);
  return contractAddresses;
}

// =============================================
// UTILITY FUNCTIONS
// =============================================

/**
 * @param {string} newRpcUrl
 * @param {string} newPrivateKey
 */
function setSigner(newRpcUrl, newPrivateKey) {
  return setSigner$1(newRpcUrl, newPrivateKey);
}
async function getSigner(chain = 'localhost') {
  return getSigner$1(chain);
}

/**
 * @param {ethers.BytesLike} signature
 */
function generatePassword(signature) {
  try {
    const hexSignature = ethers.ethers.hexlify(signature);
    const hash = ethers.ethers.keccak256(hexSignature);
    console.log("Generated password:", hash);
    return hash;
  } catch (error) {
    console.error("Error generating password:", error);
    return null;
  }
}

/**
 * @param {string | Uint8Array} message
 * @param {ethers.SignatureLike} signature
 */
async function verifySignature(message, signature) {
  try {
    const recoveredAddress = ethers.ethers.verifyMessage(message, signature);
    return recoveredAddress;
  } catch (error) {
    console.error("Error verifying signature:", error);
    return null;
  }
}

/**
 * @param {string} gunPrivateKey
 */
async function gunToEthAccount(gunPrivateKey) {
  const base64UrlToHex = (/** @type {string} */base64url) => {
    const padding = "=".repeat((4 - base64url.length % 4) % 4);
    const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/") + padding;
    const binary = atob(base64);
    return Array.from(binary, char => char.charCodeAt(0).toString(16).padStart(2, "0")).join("");
  };
  const hexPrivateKey = "0x" + base64UrlToHex(gunPrivateKey);
  const wallet = new ethers.ethers.Wallet(hexPrivateKey);

  // Genera nuove coppie di chiavi SEA
  const pair = await SEA$1.pair();
  const v_pair = await SEA$1.pair();
  const s_pair = await SEA$1.pair();

  // Genera password e cifra le coppie
  const signature = await wallet.signMessage(MESSAGE_TO_SIGN);
  const password = generatePassword(signature);
  const encryptedPair = await encrypt(pair, password);
  const encryptedV_pair = await encrypt(v_pair, password);
  const encryptedS_pair = await encrypt(s_pair, password);

  // Genera gli account di viewing e spending
  const viewingAccount = await gunToEthAccount(v_pair.priv);
  const spendingAccount = await gunToEthAccount(s_pair.priv);
  return {
    account: wallet,
    publicKey: wallet.address,
    privateKey: hexPrivateKey,
    pair: pair,
    v_pair: v_pair,
    s_pair: s_pair,
    ethAddress: wallet.address,
    ethPrivateKey: hexPrivateKey,
    env_pair: encryptedPair,
    env_v_pair: encryptedV_pair,
    env_s_pair: encryptedS_pair,
    publicKeys: {
      viewingPublicKey: v_pair.epub,
      spendingPublicKey: spendingAccount.publicKey,
      ethViewingAddress: viewingAccount.publicKey
    }
  };
}

/**
 * @param {string} encryptedPair
 * @param {any} password
 */
async function decryptPair(encryptedPair, password) {
  try {
    const keypair = {
      epriv: password,
      epub: password
    };
    return await decrypt(encryptedPair, keypair);
  } catch (error) {
    console.error("Error decrypting key pair:", error);
    return null;
  }
}

/**
 * @param {string} encryptedPair
 * @param {any} password
 */
function decryptPairFromPassword(encryptedPair, password) {
  const encryptionKeypair = {
    epriv: password,
    epub: password
  };
  return decrypt(encryptedPair, encryptionKeypair);
}
async function ethToGunAccount() {
  const signer = /** @type {ExtendedSigner} */await getSigner();
  console.log("Signer:", signer);
  const signature = await signer.signMessage(MESSAGE_TO_SIGN);
  console.log("Signature:", signature);
  const password = generatePassword(signature);
  console.log("Password:", password);
  const pair = await SEA$1.pair();
  const v_pair = await SEA$1.pair();
  const s_pair = await SEA$1.pair();
  const encryptedPair = await encrypt(pair, password);
  const encryptedV_pair = await encrypt(v_pair, password);
  const encryptedS_pair = await encrypt(s_pair, password);
  const viewingAccount = await gunToEthAccount(v_pair.priv);
  const spendingAccount = await gunToEthAccount(s_pair.priv);
  return {
    pair: pair,
    v_pair: v_pair,
    s_pair: s_pair,
    ethAddress: signer.address,
    ethPrivateKey: signer.privateKey,
    env_pair: encryptedPair,
    env_v_pair: encryptedV_pair,
    env_s_pair: encryptedS_pair,
    publicKeys: {
      viewingPublicKey: v_pair.epub,
      spendingPublicKey: spendingAccount.publicKey,
      ethViewingAddress: viewingAccount.publicKey
    }
  };
}

/**
 * @param {any} address
 */
async function createAndStoreEncryptedPair(address) {
  const gun = this;
  try {
    const {
      pair,
      v_pair,
      s_pair,
      publicKeys
    } = await ethToGunAccount();
    gun.get("gun-eth").get("users").get(address).put({
      pair,
      v_pair,
      s_pair,
      publicKeys
    });
    console.log("Encrypted pairs and public keys stored for:", address);
  } catch (error) {
    console.error("Error creating and storing encrypted pair:", error);
    throw error;
  }
}

/**
 * @param {any} address
 * @param {any} signature
 */
async function getAndDecryptPair(address, signature) {
  try {
    const gun = this;
    const encryptedData = await gun.get("gun-eth").get("users").get(address).get("pair").then();
    if (!encryptedData) {
      throw new Error("No encrypted data found for this address");
    }
    const password = generatePassword(signature);
    const decryptedPair = await decrypt(encryptedData, {
      epriv: password,
      epub: password
    });
    console.log(decryptedPair);
    return decryptedPair;
  } catch (error) {
    console.error("Error retrieving and decrypting pair:", error);
    return null;
  }
}

/**
 * Crea una firma utilizzando il signer corrente
 * @param {string} message - Messaggio da firmare
 * @returns {Promise<string>} Firma generata
 */
async function createSignature(message) {
  const signer = /** @type {ExtendedSigner} */await getSigner();
  return signer.signMessage(message);
}

// =============================================
// GUN EXTENSIONS
// =============================================

/**
 * @param {{ chain: any; }} Gun
 */
function extendGunWithStealth(Gun) {
  /** @type {StealthMethodsBase} */
  const stealthMethods = {
    stealth: async function (method, ...args) {
      const stealth = new StealthChain(/** @type {GunExtended} */ /** @type {unknown} */this),
        methods = {
          generate: stealth.generateStealthAddress.bind(stealth),
          announce: stealth.announceStealthPayment.bind(stealth),
          getPayments: stealth.getStealthPayments.bind(stealth),
          recover: stealth.recoverStealthFunds.bind(stealth),
          publish: stealth.publishStealthKeys.bind(stealth)
        };
      if (!(method in methods)) {
        throw new Error(`Unknown stealth method: ${method}`);
      }
      return methods[method](...args);
    },
    generateStealthAddress: async function (recipientAddress, signature, options = {}) {
      const stealth = new StealthChain(/** @type {GunExtended} */ /** @type {unknown} */this);
      return stealth.generateStealthAddress(recipientAddress, signature, options);
    },
    announceStealthPayment: async function (stealthAddress, senderPublicKey, spendingPublicKey, signature, options = {}) {
      const stealth = new StealthChain(/** @type {GunExtended} */ /** @type {unknown} */this);
      return stealth.announceStealthPayment(stealthAddress, senderPublicKey, spendingPublicKey, signature, options);
    },
    getStealthPayments: async function (signature, options = {}) {
      const stealth = new StealthChain(/** @type {GunExtended} */ /** @type {unknown} */this);
      return stealth.getStealthPayments(signature, options);
    },
    recoverStealthFunds: async function (stealthAddress, senderPublicKey, signature, spendingPublicKey) {
      const stealth = new StealthChain(/** @type {GunExtended} */ /** @type {unknown} */this);
      return stealth.recoverStealthFunds(stealthAddress, senderPublicKey, signature, spendingPublicKey);
    },
    publishStealthKeys: async function (signature) {
      const stealth = new StealthChain(/** @type {GunExtended} */ /** @type {unknown} */this);
      return stealth.publishStealthKeys(signature);
    },
    monitorStealthEvents: function (callback) {
      new StealthChain(/** @type {GunExtended} */ /** @type {unknown} */this);
        const gun = /** @type {GunExtended} */ /** @type {unknown} */this;
      const chain = gun.get('gun-eth').get('stealth-payments').map().on((payment, id) => {
        if (payment) {
          callback({
            type: 'offChain',
            event: 'announcement',
            data: {
              ...payment,
              id
            }
          });
        }
      });
      (async () => {
        try {
          const signer = /** @type {ExtendedSigner} */await getSigner(),
            chainConfig = getContractAddresses('localhost'),
            contract = new ethers.ethers.Contract(chainConfig.STEALTH_ANNOUNCER_ADDRESS, STEALTH_ANNOUNCER_ABI, signer);
          contract.on('PaymentAnnounced', function (sender, recipient, stealthAddress, event) {
            callback({
              type: 'onChain',
              event: 'PaymentAnnounced',
              data: {
                sender: sender,
                recipient: recipient,
                stealthAddress: stealthAddress,
                blockNumber: event.blockNumber,
                transactionHash: event.transactionHash
              }
            });
          });
        } catch (error) {
          console.warn('Failed to setup on-chain event monitoring:', error);
        }
      })();
      return chain;
    }
  };
  Object.assign(Gun.chain, stealthMethods);
}

/**
 * @param {import("gun").IGun} Gun
 */
function extendGun(Gun) {
  /** @type {BaseMethods} */
  const baseMethods = {
    MESSAGE_TO_SIGN,
    setSigner: function (/** @type {string} */newRpcUrl, /** @type {string} */newPrivateKey) {
      console.log("Signer configuration set");
      return this;
    },
    getSigner,
    verifySignature,
    generatePassword,
    createSignature,
    createAndStoreEncryptedPair,
    getAndDecryptPair,
    ethToGunAccount,
    gunToEthAccount,
    getAddressesForChain
  };
  Object.assign(Gun.chain, baseMethods);

  // Extend with proof functionality
  ProofChain.extendGun(Gun);

  // Extend with stealth functionality
  extendGunWithStealth(Gun);

  // Add retry mechanism
  const methods = ['stealth', 'generateStealthAddress', 'announceStealthPayment', 'getStealthPayments', 'recoverStealthFunds', 'publishStealthKeys', 'createAndStoreEncryptedPair', 'getAndDecryptPair', 'ethToGunAccount', 'gunToEthAccount', 'createSignature', 'setSigner'];
  methods.forEach(method => {
    const original = Gun.chain[method];
    if (original) {
      Gun.chain[method] = async function (/** @type {any} */...args) {
        const maxRetries = 3;
        let lastError;
        for (let i = 0; i < maxRetries; i++) {
          try {
            return await original.apply(this, args);
          } catch (error) {
            console.warn(`Attempt ${i + 1}/${maxRetries} failed:`, error);
            lastError = error;
            await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
          }
        }
        throw lastError;
      };
    }
  });
}

/**
 * Inizializza Gun con le estensioni e le opzioni specificate
 * @param {string} chain - Chain da utilizzare
 * @param {Object} [options] - Opzioni di configurazione per Gun
 * @returns {Promise<IGunInstance>} Istanza di Gun configurata
 */
async function initializeGun(chain = 'localhost', options = {}) {
  await initialize(chain);
  extendGun(Gun);
  const gun = /** @type {IGunInstance} */Gun(options);
  return gun;
}

/**
 * Classe principale per l'integrazione di Gun con Ethereum
 */
class GunEth {
  static keypair = null;
  static v_keypair = null;
  static s_keypair = null;
  static async init(chain = 'localhost') {
    await initialize(chain);
    return this;
  }

  // Metodi statici
  static generateRandomId = generateRandomId;
  static generatePassword = generatePassword;
  static getSigner = getSigner;
  static verifySignature = verifySignature;
  static MESSAGE_TO_SIGN = MESSAGE_TO_SIGN;
  static getContractAddresses = getContractAddresses;
  static extendGun = extendGun;
  static initializeGun = initializeGun;
  static setSigner = setSigner;
  static gunToEthAccount = gunToEthAccount;
  static decryptPair = decryptPair;
  static decryptPairFromPassword = decryptPairFromPassword;
  static ethToGunAccount = ethToGunAccount;
  static createAndStoreEncryptedPair = createAndStoreEncryptedPair;
  static getAndDecryptPair = getAndDecryptPair;
  static createSignature = createSignature;
  static LOCAL_CONFIG = LOCAL_CONFIG;
  static contractAddresses = contractAddresses;
}

// @ts-nocheck


/**
 * @typedef {Object} BubbleProviderOptions
 * @property {string} rpcUrl - RPC URL for the provider
 * @property {string} chain - Chain name (e.g. 'localhost', 'optimismSepolia')
 * @property {Object} gun - Gun instance
 * @property {Object} keypair - Keypair for encryption
 * @property {string} keypair.epub - Public encryption key
 * @property {string} keypair.epriv - Private encryption key
 * @property {string} [contractAddress] - Optional custom contract address
 * @property {Object} [contractAbi] - Optional custom contract ABI
 */

/**
 * @typedef {Object} BubbleDetails
 * @property {string} id - Bubble ID
 * @property {string} name - Bubble name
 * @property {string} owner - Owner's Ethereum address
 * @property {boolean} isPrivate - Whether the bubble is private
 * @property {number} createdAt - Creation timestamp
 */

/**
 * @typedef {Object} FileMetadata
 * @property {string} name - File name
 * @property {string} owner - File owner
 * @property {string} filePath - File path
 * @property {number} created - Creation timestamp
 * @property {number} updated - Last update timestamp
 * @property {number} size - File size in bytes
 * @property {Object} encryptionInfo - Encryption info
 * @property {string} encryptionInfo.ownerEpub - Owner's public key
 * @property {string} encryptionInfo.ownerAddress - Owner's address
 */

/**
 * @typedef {Object} DeleteResult
 * @property {boolean} success - Whether deletion was successful
 * @property {string} [message] - Optional status message
 */

/**
 * @typedef {Object} DeleteBubbleResult
 * @property {boolean} success - Whether deletion was successful
 * @property {string} [message] - Optional status message
 */

/**
 * Base class for bubble storage providers
 */
class BaseBubbleProvider {
  /**
   * Creates a new bubble provider instance
   * @param {BubbleProviderOptions} options - Provider configuration options
   */
  constructor(options) {
    const {
      rpcUrl,
      chain,
      gun,
      keypair,
      contractAddress,
      contractAbi
    } = options;
    if (!rpcUrl) throw new Error("RPC URL required");
    if (!chain) throw new Error("Chain name required");
    if (!gun) throw new Error("Gun instance required");
    if (!keypair || !keypair.epub || !keypair.epriv) {
      throw new Error("Valid keypair required");
    }
    this.provider = new ethers.ethers.JsonRpcProvider(rpcUrl);

    // Use custom contract address and ABI if provided, otherwise use defaults
    const addresses = getAddressesForChain(chain);
    const contractAddr = contractAddress || addresses?.BUBBLE_REGISTRY_ADDRESS;
    const abi = contractAbi || BUBBLE_REGISTRY_ABI;
    if (!contractAddr) {
      throw new Error(`No contract address found for chain: ${chain}`);
    }

    /** @type {BubbleRegistryContract} */
    this.contract = new ethers.ethers.Contract(contractAddr, abi, this.provider);

    // Initialize Gun and keypair in base class
    this.gun = gun;
    this.keypair = keypair;
    this.bubbleRoot = this.gun.get("bubbles");

    // Key cache
    this.keyPairs = new Map();
  }

  /**
   * Verifies request signature
   * @param {string} address - Ethereum address of the requester
   * @param {string} message - Message that was signed
   * @param {string} signature - Signature of the message
   * @returns {Promise<boolean>} - Whether the signature is valid
   */
  async verifyRequest(address, message, signature) {
    try {
      const recoveredAddress = ethers.ethers.verifyMessage(message, signature);
      return recoveredAddress.toLowerCase() === address.toLowerCase();
    } catch (error) {
      return false;
    }
  }

  /**
   * Manages user keys
   * @param {string} address - Ethereum address of the user
   * @returns {Promise<Object>} - Key pair of the user
   */
  async getUserKeyPair(address) {
    const normalizedAddress = address.toLowerCase();
    let pair = this.keyPairs.get(normalizedAddress);
    if (!pair) {
      pair = await SEA.pair();
      this.keyPairs.set(normalizedAddress, pair);
    }
    return pair;
  }

  /**
   * Verifies bubble access
   * @param {string} bubbleId - ID of the bubble
   * @param {string} userAddress - Ethereum address of the user
   * @returns {Promise<boolean>} - Whether the user has access to the bubble
   */
  async verifyBubbleAccess(bubbleId, userAddress) {
    console.log("\n=== Checking bubble access ===");
    console.log("Bubble ID:", bubbleId);
    console.log("User Address:", userAddress);
    const hasAccess = await this.contract.hasAccess(bubbleId, userAddress);
    console.log("Access check result:", hasAccess);
    if (!hasAccess) {
      console.error("Access denied");
      throw new Error("No access to bubble");
    }
    console.log("Access verified successfully");
    return true;
  }

  /**
   * Verifies bubble ownership
   * @param {string} bubbleId - ID of the bubble
   * @param {string} ownerAddress - Ethereum address of the owner
   * @returns {Promise<boolean>} - Whether the user is the owner of the bubble
   */
  async verifyBubbleOwnership(bubbleId, ownerAddress) {
    console.log("\n=== Verifying bubble ownership ===");
    console.log("Bubble ID:", bubbleId);
    console.log("Owner address:", ownerAddress);
    console.log("Getting bubble data from contract...");
    const bubbleData = await this.contract.getBubbleDetails(bubbleId);
    const onChainOwner = bubbleData[1]; // owner is the second returned element

    console.log("On-chain owner:", onChainOwner);
    console.log("Expected owner:", ownerAddress);
    if (onChainOwner.toLowerCase() !== ownerAddress.toLowerCase()) {
      throw new Error("Not bubble owner");
    }
    console.log("Ownership verified successfully");
    return true;
  }

  /**
   * Grants on-chain access to a target address
   * @param {string} bubbleId - ID of the bubble
   * @param {string} targetAddress - Ethereum address to grant access to
   * @returns {Promise<void>}
   */
  async grantOnChainAccess(bubbleId, targetAddress) {
    console.log("\n=== Starting grantOnChainAccess ===");
    console.log("Getting signer...");
    const signer = await getSigner();
    console.log("Signer obtained");
    console.log("Connecting contract with signer...");
    const contractWithSigner = this.contract.connect(signer);
    console.log("Contract connected");
    console.log("Sending grantAccess transaction...");
    console.log("Bubble ID:", bubbleId);
    console.log("Target Address:", targetAddress);
    const tx = await contractWithSigner.grantAccess(bubbleId, targetAddress);
    console.log("Transaction sent:", tx.hash);
    console.log("Waiting for transaction confirmation...");
    await tx.wait();
    console.log("Transaction confirmed:", tx.hash);
    console.log("=== grantOnChainAccess completed successfully ===");
  }

  /**
   * Puts data into GunDB
   * @param {string} path - Path in GunDB
   * @param {Object} data - Data to put
   * @param {number} [maxRetries=3] - Maximum number of retries
   * @returns {Promise<void>}
   */
  async putGunData(path, data, maxRetries = 3) {
    let retries = 0;
    while (retries < maxRetries) {
      try {
        await new Promise((resolve, reject) => {
          this.gun.get(path).put(data, ack => {
            if (ack.err) reject(new Error(ack.err));else resolve();
          });
        });
        return;
      } catch (error) {
        retries++;
        if (retries === maxRetries) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }

  /**
   * Gets a node from GunDB
   * @typedef {Object} GunNode
   * @property {Object} data - Data of the node (if any)
   * @property {string} err - Error message if any
   * @property {any} content - Content of the node
   * @param {string} path - Path in GunDB
   * @param {number} [maxRetries=3] - Maximum number of retries
   * @returns {Promise<GunNode>} - Node data
   */
  async getGunNode(path, maxRetries = 3) {
    let retries = 0;
    let node = null;
    while (retries < maxRetries) {
      try {
        node = await new Promise((resolve, reject) => {
          const timeoutId = setTimeout(() => {
            reject(new Error("Gun node fetch timeout"));
          }, 5000);
          this.gun.get(path).once(data => {
            clearTimeout(timeoutId);
            resolve(data);
          });
        });
        if (node) break;
        retries++;
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Gun node fetch attempt ${retries + 1} failed:`, error);
        retries++;
        if (retries === maxRetries) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    return node;
  }

  /**
   * Handles bubble creation
   * @param {Object} params - Parameters for bubble creation
   * @param {string} params.name - Name of the bubble
   * @param {boolean} params.isPrivate - Whether the bubble is private
   * @param {string} params.userAddress - Ethereum address of the user
   * @returns {Promise<BubbleDetails>} - Metadata of the created bubble
   */
  async handleCreateBubble(params) {
    const {
      name,
      isPrivate,
      userAddress
    } = params;
    if (!name || typeof isPrivate !== "boolean" || !userAddress) {
      throw new Error("Invalid parameters for bubble creation");
    }
    try {
      console.log("Starting bubble creation...");
      console.log("Parameters:", params);
      const signer = await getSigner();
      const contractWithSigner = this.contract.connect(signer);
      const tx = await contractWithSigner.createBubble(name, isPrivate);
      const receipt = await tx.wait();
      const event = receipt.logs.find(log => {
        try {
          const parsedLog = this.contract.interface.parseLog(log);
          return parsedLog.name === "BubbleCreated";
        } catch (e) {
          return false;
        }
      });
      if (!event) {
        throw new Error("Bubble creation event not found");
      }
      const parsedEvent = this.contract.interface.parseLog(event);
      const bubbleId = parsedEvent.args[0];
      const metadata = {
        id: bubbleId,
        name,
        owner: userAddress,
        isPrivate,
        createdAt: Date.now()
      };
      await this.putGunData(`bubbles/${bubbleId}`, metadata);
      return metadata;
    } catch (error) {
      console.error("Error creating bubble:", error);
      throw error;
    }
  }

  /**
   * Handles granting permission to a bubble
   * @param {string} bubbleId - ID of the bubble
   * @param {string} targetAddress - Ethereum address of the target user
   * @param {string} granterAddress - Ethereum address of the granter
   * @param {Object} options - Additional options
   * @param {string} options.granteeEpub - Public encryption key of the grantee
   * @returns {Promise<Object>} - Result of the permission grant
   */
  async handleGrantPermission(bubbleId, targetAddress, granterAddress, options) {
    try {
      if (!options?.granteeEpub) {
        throw new Error("Grantee epub key is required");
      }
      await this.verifyBubbleOwnership(bubbleId, granterAddress);
      await this.grantOnChainAccess(bubbleId, targetAddress);
      return {
        success: true
      };
    } catch (error) {
      console.error("Error in handleGrantPermission:", error);
      throw error;
    }
  }

  /**
   * Handles file upload to a bubble
   * @abstract
   * @param {string} bubbleId - ID of the bubble
   * @param {string} fileName - Name of the file
   * @param {string} content - File content
   * @param {string} userAddress - Ethereum address of the uploader
   * @returns {Promise<FileMetadata>} - Metadata of the uploaded file
   */
  async handleFileUpload(bubbleId, fileName, content, userAddress) {
    throw new Error('handleFileUpload must be implemented');
  }

  /**
   * Handles file deletion from a bubble
   * @abstract
   * @param {string} bubbleId - ID of the bubble
   * @param {string} fileName - Name of the file
   * @param {string} userAddress - Ethereum address of the user
   * @returns {Promise<DeleteResult>} - Result of the deletion
   */
  async handleDeleteFile(bubbleId, fileName, userAddress) {
    throw new Error('handleDeleteFile must be implemented');
  }

  /**
   * Handles file download from a bubble
   * @abstract
   * @param {string} bubbleId - ID of the bubble
   * @param {string} fileName - Name of the file
   * @param {string} userAddress - Ethereum address of the user
   * @returns {Promise<{content: any, metadata: Object}>} - File content and metadata
   */
  async handleFileDownload(bubbleId, fileName, userAddress) {
    throw new Error('handleFileDownload must be implemented');
  }

  /**
   * Handles bubble deletion
   * @abstract
   * @param {string} bubbleId - ID of the bubble
   * @param {string} userAddress - Ethereum address of the user
   * @returns {Promise<DeleteBubbleResult>} - Result of the deletion
   */
  async handleDeleteBubble(bubbleId, userAddress) {
    throw new Error('handleDeleteBubble must be implemented');
  }
}

/**
 * @typedef {Object} FileMetadata
 * @property {string} name - Name of the file
 * @property {string} owner - Address of file owner
 * @property {number} created - Creation timestamp
 * @property {number} updated - Last update timestamp
 * @property {string} filePath - File path
 * @property {number} size - File size
 * @property {Object} encryptionInfo - Encryption info
 * @property {string} encryptionInfo.ownerEpub - Owner's public key
 * @property {string} encryptionInfo.ownerAddress - Owner's address
 * @property {boolean} readOnly - Whether file is read-only
 */

class GUNBubbleProvider extends BaseBubbleProvider {
  constructor(options) {
    super(options);

    // Configura il Gun user
    this.user = this.gun.user();
    this.user.auth(this.keypair);

    // Debug log
    console.log("GUNBubbleProvider initialized:", {
      hasGun: !!this.gun,
      hasUser: !!this.user,
      hasKeypair: !!this.keypair,
      hasBubbleRoot: !!this.bubbleRoot,
      gunOpts: this.gun._.opt
    });

    // Verifica che Gun sia pronto
    this.gun.on('hi', peer => {
      console.log('Connected to peer:', peer);
    });
    this.gun.on('error', error => {
      console.error('Gun error:', error);
    });
  }

  /**
   * @typedef {Object} FileDownloadParams
   * @property {string} bubbleId - ID of the bubble
   * @property {string} fileName - Name of the file to download
   * @property {string} userAddress - Ethereum address of the user
   */

  /**
   * Handles file download
   * @param {string} bubbleId - ID of the bubble
   * @param {string} fileName - Name of the file to download
   * @param {string} userAddress - Ethereum address of the user
   */
  async handleFileDownload(bubbleId, fileName, userAddress) {
    try {
      if (!this.keypair) throw new Error('Keypair not initialized');
      console.log("\n=== Starting file download ===");
      console.log("Bubble ID:", bubbleId);
      console.log("File name:", fileName);
      console.log("User address:", userAddress);
      await this.verifyBubbleAccess(bubbleId, userAddress);
      const filePath = `bubbles/${bubbleId}/files/${fileName}`;
      console.log("Reading from path:", filePath);
      const fileData = await new Promise(resolve => {
        this.gun.get(filePath).once(data => {
          console.log("File data retrieved:", data);
          resolve(data);
        });
      });
      if (!fileData) {
        console.error("File not found at path:", filePath);
        throw new Error('File not found');
      }
      let content;
      const normalizedUserAddress = userAddress.toLowerCase();
      if (fileData.owner.toLowerCase() === normalizedUserAddress) {
        console.log("User is owner, decrypting with owner key");
        content = await decrypt(fileData.content, this.keypair);
      } else {
        console.log("User is not owner, looking for shared content");
        const sharedPath = `${filePath}/sharedWith/${normalizedUserAddress}`;
        console.log("Looking for shared data at:", sharedPath);
        const sharedData = await new Promise(resolve => {
          this.gun.get(sharedPath).once(data => {
            console.log("Shared data loaded:", data);
            resolve(data);
          });
        });
        if (!sharedData || !sharedData.content || !sharedData.ownerEpub) {
          console.error("Shared data not found or incomplete:", sharedData);
          throw new Error('Shared content not found');
        }
        try {
          // Use deriveSharedKey to get the shared key
          const sharedKeypair = await deriveSharedKey(sharedData.ownerEpub, this.keypair);
          console.log("Shared key derived");

          // Decrypt the content using the shared key
          content = await decrypt(sharedData.content, sharedKeypair);
          if (!content) {
            throw new Error('Failed to decrypt content');
          }
          console.log("Content decrypted successfully");
        } catch (error) {
          console.error("Decryption error:", {
            phase: error.message.includes('key') ? 'key derivation' : 'content decryption',
            error: error.message,
            sharedData: {
              hasContent: !!sharedData.content,
              hasOwnerEpub: !!sharedData.ownerEpub,
              contentLength: sharedData.content?.length
            }
          });
          throw error;
        }
      }
      return {
        content,
        metadata: {
          name: fileData.name,
          owner: fileData.owner,
          filePath: fileData.filePath,
          created: fileData.created,
          updated: fileData.updated,
          size: fileData.size,
          readOnly: fileData.readOnly || false,
          encryptionInfo: fileData.encryptionInfo
        }
      };
    } catch (error) {
      console.error('Error downloading file:', error);
      throw error;
    }
  }

  /**
   * @typedef {Object} FileUploadOptions
   * @property {string} bubbleId - ID of the bubble
   * @property {string} fileName - Name of the file
   * @property {string} content - Content of the file
   * @property {string} userAddress - Address of the user
   */
  async handleFileUpload(bubbleId, fileName, content, userAddress) {
    try {
      console.log("\n=== Starting file upload ===");
      console.log("Bubble ID:", bubbleId);
      console.log("File name:", fileName);
      console.log("User address:", userAddress);
      if (!this.keypair) {
        throw new Error('Keypair not initialized');
      }
      await this.verifyBubbleAccess(bubbleId, userAddress);

      // Encrypt the content
      console.log("Encrypting content...");
      const encryptedContent = await encrypt(content, this.keypair);
      console.log("Content encrypted successfully");

      // Create the file metadata
      const fileMetadata = {
        name: fileName,
        owner: userAddress,
        content: encryptedContent,
        created: Date.now(),
        updated: Date.now(),
        readOnly: false,
        sharedWith: {}
      };
      console.log("Saving to GUN...");

      // Use a more direct approach with GUN
      return new Promise((resolve, reject) => {
        // Create the full path for the file
        const filePath = `bubbles/${bubbleId}/files/${fileName}`;
        console.log("File path:", filePath);

        // Save directly to the path as an object
        this.gun.get(filePath).put(fileMetadata, ack => {
          if (ack.err) {
            console.error("Save error:", ack.err);
            reject(new Error(ack.err));
            return;
          }
          console.log("Initial save successful, verifying...");

          // Verify the save
          this.gun.get(filePath).once(data => {
            if (!data || !data.content) {
              console.error("Verification failed:", data);
              reject(new Error('File verification failed'));
              return;
            }
            console.log("File saved and verified successfully:", {
              name: data.name,
              owner: data.owner,
              hasContent: !!data.content,
              created: new Date(data.created).toISOString()
            });
            resolve(fileMetadata);
          });
        });

        // Set a timeout for the verification
        setTimeout(() => {
          this.gun.get(filePath).once(data => {
            if (data && data.content) {
              console.log("Save operation taking too long, checking state...");
              console.log("Data found after timeout, resolving...");
              resolve(fileMetadata);
            }
          });
        }, 5000);
      });
    } catch (error) {
      console.error('Error uploading file:', error);
      throw error;
    }
  }

  /**
   * @typedef {Object} GrantPermissionOptions
   * @property {string} granteeEpub - Public encryption key of grantee
   */
  async handleGrantPermission(bubbleId, targetAddress, granterAddress, options = {}) {
    try {
      console.log("\n=== Starting handleGrantPermission ===");
      if (!options.granteeEpub) {
        throw new Error("Grantee epub key is required");
      }
      await this.verifyBubbleOwnership(bubbleId, granterAddress);
      await this.grantOnChainAccess(bubbleId, targetAddress);
      const filesPath = `bubbles/${bubbleId}/files`;
      console.log("Files path:", filesPath);
      const fileData = await this.getGunNode(`${filesPath}/secret.txt`);
      console.log("File data:", fileData);
      if (!fileData || !fileData.content) {
        console.log("No file content found");
        return {
          success: true
        };
      }
      try {
        // Decrypt the original content
        const decryptedContent = await decrypt(fileData.content, this.keypair);
        console.log("Original content decrypted");

        // Use deriveSharedKey to get the shared key
        const sharedKeypair = await deriveSharedKey(options.granteeEpub, this.keypair);
        console.log("Shared key derived successfully");

        // Encrypt the content with the shared key
        const encryptedContent = await encrypt(decryptedContent, sharedKeypair);
        console.log("Content re-encrypted with shared key");
        const sharedPath = `${filesPath}/secret.txt/sharedWith/${targetAddress.toLowerCase()}`;
        console.log("Saving shared data at:", sharedPath);
        const sharedData = {
          address: targetAddress,
          grantedAt: Date.now(),
          content: encryptedContent,
          ownerEpub: this.keypair.epub
        };
        await this.putGunData(sharedPath, sharedData);
        console.log("Shared data saved successfully");
        return {
          success: true
        };
      } catch (error) {
        console.error("Error processing file:", error);
        throw error;
      }
    } catch (error) {
      console.error("Error in handleGrantPermission:", error);
      throw error;
    }
  }

  /**
   * @typedef {Object} BubbleParams
   * @property {string} name - The name of the bubble
   * @property {boolean} isPrivate - Whether the bubble is private
   * @property {string} userAddress - The address of the user creating the bubble
   */

  /**
   * Handles the creation of a new bubble.
   * @param {BubbleParams} params - The parameters for bubble creation
   */
  async handleCreateBubble(params) {
    const {
      name,
      isPrivate,
      userAddress
    } = params;
    if (!name || typeof isPrivate !== 'boolean' || !userAddress) {
      throw new Error('Invalid parameters for bubble creation');
    }
    try {
      console.log("Starting bubble creation...");
      console.log("Parameters:", params);

      // Get the signer
      console.log("Getting signer...");
      const signer = await getSigner();

      // Create the bubble on-chain
      console.log("Creating bubble on-chain...");
      const contractWithSigner = this.contract.connect(signer);
      const tx = await contractWithSigner.createBubble(name, isPrivate);
      console.log("Transaction sent:", tx.hash);
      console.log("Waiting for transaction...");
      const receipt = await tx.wait();

      // Extract the bubble ID from the event
      console.log("Parsing event...");
      const event = receipt.logs.find(log => {
        try {
          const parsedLog = this.contract.interface.parseLog(log);
          return parsedLog.name === 'BubbleCreated';
        } catch (e) {
          return false;
        }
      });
      if (!event) {
        throw new Error('Bubble creation event not found');
      }
      const parsedEvent = this.contract.interface.parseLog(event);
      const bubbleId = parsedEvent.args[0];
      console.log("Bubble ID:", bubbleId);

      // Create the metadata
      const metadata = {
        id: bubbleId,
        name,
        owner: userAddress,
        isPrivate,
        createdAt: Date.now()
      };

      // Save the metadata to GUN
      console.log("Saving metadata to GUN...");
      await new Promise((resolve, reject) => {
        this.gun.get('bubbles').get(bubbleId).put(metadata, ack => {
          if (ack.err) {
            console.error("GUN save error:", ack.err);
            reject(new Error(ack.err));
          } else {
            console.log("GUN save successful");
            resolve();
          }
        });
      });
      console.log("Metadata saved successfully:", metadata);
      return metadata;
    } catch (error) {
      console.error('Error creating bubble:', error);
      throw error;
    }
  }

  /**
   * @typedef {Object} DeleteFileOptions
   * @property {string} bubbleId - The ID of the bubble
   * @property {string} fileName - The name of the file to delete
   * @property {string} userAddress - The address of the user requesting the deletion
   */
  async handleDeleteFile(bubbleId, fileName, userAddress) {
    try {
      console.log("\n=== Starting file deletion ===");
      console.log("Bubble ID:", bubbleId);
      console.log("File name:", fileName);
      console.log("User address:", userAddress);

      // Verify access
      await this.verifyBubbleAccess(bubbleId, userAddress);

      // Build the file path
      const filePath = `bubbles/${bubbleId}/files/${fileName}`;
      console.log("Deleting file at path:", filePath);

      // Load the file data to verify ownership
      const fileData = await new Promise(resolve => {
        this.gun.get(filePath).once(resolve);
      });
      if (!fileData) {
        throw new Error('File not found');
      }

      // Verify that the user is the owner
      if (fileData.owner.toLowerCase() !== userAddress.toLowerCase()) {
        throw new Error('Only file owner can delete files');
      }

      // Delete the file and its metadata
      return new Promise((resolve, reject) => {
        // First delete the shared data
        const sharedWithNode = this.gun.get(filePath).get('sharedWith');
        sharedWithNode.map().once((data, key) => {
          if (key !== '_') {
            sharedWithNode.get(key).put(null);
          }
        });

        // Then delete the file itself by setting all fields to null
        const fileNode = this.gun.get(filePath);
        const nullData = {
          name: null,
          owner: null,
          content: null,
          created: null,
          updated: null,
          readOnly: null,
          sharedWith: null
        };
        fileNode.put(nullData, ack => {
          if (ack.err) {
            console.error("Error nullifying file data:", ack.err);
            reject(new Error(ack.err));
            return;
          }

          // Remove the file reference from the bubble's file list
          this.gun.get(`bubbles/${bubbleId}/files`).get(fileName).put(null, ack => {
            if (ack.err) {
              console.error("Error removing file reference:", ack.err);
              reject(new Error(ack.err));
              return;
            }
            console.log("File deleted successfully");
            resolve({
              success: true
            });
          });
        });
      });
    } catch (error) {
      console.error('Error deleting file:', error);
      throw error;
    }
  }

  /**
   * @typedef {Object} DeleteBubbleResult
   * @property {boolean} success - Indicates if the bubble was successfully deleted
   */

  /**
   * Deletes a bubble and all its contents.
   * @param {string} bubbleId - The ID of the bubble to delete.
   * @param {string} userAddress - The address of the user requesting the deletion.
   * @returns {Promise<DeleteBubbleResult>} - The result of the deletion operation.
   */
  async handleDeleteBubble(bubbleId, userAddress) {
    try {
      console.log("\n=== Starting bubble deletion ===");
      console.log("Bubble ID:", bubbleId);
      console.log("User address:", userAddress);

      // Verify bubble ownership
      await this.verifyBubbleOwnership(bubbleId, userAddress);

      // Build the bubble path
      const bubblePath = `bubbles/${bubbleId}`;
      console.log("Deleting bubble at path:", bubblePath);

      // Delete the bubble and all its contents
      return new Promise((resolve, reject) => {
        // First delete all files in the bubble
        this.gun.get(bubblePath).get('files').map().once((fileData, fileName) => {
          if (fileName === '_') return;

          // Delete shared data for each file
          this.gun.get(bubblePath).get('files').get(fileName).get('sharedWith').map().once((sharedData, sharedAddress) => {
            if (sharedAddress === '_') return;

            // Set shared data to null
            this.gun.get(bubblePath).get('files').get(fileName).get('sharedWith').get(sharedAddress).put(null);
          });

          // Set file metadata to null
          this.gun.get(bubblePath).get('files').get(fileName).put({
            name: null,
            owner: null,
            content: null,
            created: null,
            updated: null,
            readOnly: null,
            sharedWith: null
          });
        });

        // Then set bubble metadata to null
        this.gun.get(bubblePath).put({
          id: null,
          name: null,
          owner: null,
          isPrivate: null,
          createdAt: null,
          files: null
        }, ack => {
          if (ack.err) {
            console.error("Error nullifying bubble data:", ack.err);
            reject(new Error(ack.err));
            return;
          }
          console.log("Bubble data nullified successfully");
          resolve({
            success: true
          });
        });
      });
    } catch (error) {
      console.error('Error deleting bubble:', error);
      throw error;
    }
  }
}

exports.GUNBubbleProvider = GUNBubbleProvider;
exports.GunEth = GunEth;
exports.ProofChain = ProofChain;
exports.StealthChain = StealthChain;
